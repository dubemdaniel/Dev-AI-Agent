{"version":3,"sources":["../src/zod-to-json.ts"],"names":["z","zodToJsonSchemaOriginal"],"mappings":"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","file":"chunk-5WM4A32G.cjs","sourcesContent":["import type { JSONSchema7 } from 'json-schema';\nimport { z } from 'zod';\nimport type { ZodSchema as ZodSchemaV3 } from 'zod/v3';\nimport type { ZodType as ZodSchemaV4 } from 'zod/v4';\nimport type { Targets } from 'zod-to-json-schema';\nimport zodToJsonSchemaOriginal from 'zod-to-json-schema';\n\n// Symbol to mark schemas as already patched (for idempotency)\nconst PATCHED = Symbol('__mastra_patched__');\n\n/**\n * Recursively patch Zod v4 record schemas that are missing valueType.\n * This fixes a bug in Zod v4 where z.record(valueSchema) doesn't set def.valueType.\n * The single-arg form should set valueType but instead only sets keyType.\n */\nfunction patchRecordSchemas(schema: any): any {\n  if (!schema || typeof schema !== 'object') return schema;\n\n  // Skip if already patched (idempotency check)\n  if ((schema as any)[PATCHED]) return schema;\n  (schema as any)[PATCHED] = true;\n\n  // Check the _zod.def location (v4 structure)\n  const def = schema._zod?.def;\n\n  // Fix record schemas with missing valueType\n  if (def?.type === 'record' && def.keyType && !def.valueType) {\n    // The bug: z.record(valueSchema) puts the value in keyType instead of valueType\n    // Fix: move it to valueType and set keyType to string (the default)\n    def.valueType = def.keyType;\n    def.keyType = (z as any).string();\n  }\n\n  // Recursively patch nested schemas\n  if (!def) return schema;\n\n  if (def.type === 'object' && def.shape) {\n    const shape = typeof def.shape === 'function' ? def.shape() : def.shape;\n    for (const key of Object.keys(shape)) {\n      patchRecordSchemas(shape[key]);\n    }\n  }\n\n  if (def.type === 'array' && def.element) {\n    patchRecordSchemas(def.element);\n  }\n\n  if (def.type === 'union' && def.options) {\n    def.options.forEach(patchRecordSchemas);\n  }\n\n  if (def.type === 'record') {\n    if (def.keyType) patchRecordSchemas(def.keyType);\n    if (def.valueType) patchRecordSchemas(def.valueType);\n  }\n\n  // Handle intersection types\n  if (def.type === 'intersection') {\n    if (def.left) patchRecordSchemas(def.left);\n    if (def.right) patchRecordSchemas(def.right);\n  }\n\n  // Handle lazy types - patch the schema returned by the getter\n  if (def.type === 'lazy') {\n    // For lazy schemas, we need to patch the schema when it's accessed\n    // Store the original getter and wrap it\n    if (def.getter && typeof def.getter === 'function') {\n      const originalGetter = def.getter;\n      def.getter = function () {\n        const innerSchema = originalGetter();\n        if (innerSchema) {\n          patchRecordSchemas(innerSchema);\n        }\n        return innerSchema;\n      };\n    }\n  }\n\n  // Handle wrapper types that have innerType\n  // This covers: optional, nullable, default, catch, nullish, and any other wrappers\n  if (def.innerType) {\n    patchRecordSchemas(def.innerType);\n  }\n\n  return schema;\n}\n\nexport function zodToJsonSchema(\n  zodSchema: ZodSchemaV3 | ZodSchemaV4,\n  target: Targets = 'jsonSchema7',\n  strategy: 'none' | 'seen' | 'root' | 'relative' = 'relative',\n) {\n  const fn = 'toJSONSchema';\n\n  if (fn in z) {\n    // Zod v4 path - patch record schemas before converting\n    patchRecordSchemas(zodSchema);\n\n    return (z as any)[fn](zodSchema, {\n      unrepresentable: 'any',\n      override: (ctx: any) => {\n        // Handle both Zod v4 structures: _def directly or nested in _zod\n        const def = ctx.zodSchema?._def || ctx.zodSchema?._zod?.def;\n        // Check for date type using both possible property names\n        if (def && (def.typeName === 'ZodDate' || def.type === 'date')) {\n          ctx.jsonSchema.type = 'string';\n          ctx.jsonSchema.format = 'date-time';\n        }\n      },\n    }) as JSONSchema7;\n  } else {\n    // Zod v3 path - use the original converter\n    return zodToJsonSchemaOriginal(zodSchema as ZodSchemaV3, {\n      $refStrategy: strategy,\n      target,\n    }) as JSONSchema7;\n  }\n}\n"]}