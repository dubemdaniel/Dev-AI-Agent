{"version":3,"sources":["../src/tools/working-memory.ts","../src/index.ts"],"names":["z","ZodObject","convertSchemaToZod","createTool","MastraMemory","MessageList","Mutex","xxhash","embedManyV5","embedMany","result","zodToJsonSchema","generateEmptyFromSchema"],"mappings":"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","file":"index.cjs","sourcesContent":["import type { MemoryConfig } from '@mastra/core/memory';\nimport { createTool } from '@mastra/core/tools';\nimport { convertSchemaToZod } from '@mastra/schema-compat';\nimport type { Schema } from 'ai';\nimport { z, ZodObject } from 'zod';\nimport type { ZodType } from 'zod';\n\nexport const updateWorkingMemoryTool = (memoryConfig?: MemoryConfig) => {\n  const schema = memoryConfig?.workingMemory?.schema;\n\n  let inputSchema: ZodType = z.object({\n    memory: z\n      .string()\n      .describe(`The Markdown formatted working memory content to store. This MUST be a string. Never pass an object.`),\n  });\n\n  if (schema) {\n    inputSchema = z.object({\n      memory:\n        schema instanceof ZodObject\n          ? schema\n          : (convertSchemaToZod({ jsonSchema: schema } as Schema).describe(\n              `The JSON formatted working memory content to store.`,\n            ) as ZodObject<any>),\n    });\n  }\n\n  return createTool({\n    id: 'update-working-memory',\n    description: `Update the working memory with new information. Any data not included will be overwritten.${schema ? ' Always pass data as string to the memory field. Never pass an object.' : ''}`,\n    inputSchema,\n    execute: async params => {\n      const { context, threadId, memory, resourceId } = params;\n      if (!threadId || !memory || !resourceId) {\n        throw new Error('Thread ID, Memory instance, and resourceId are required for working memory updates');\n      }\n\n      let thread = await memory.getThreadById({ threadId });\n\n      if (!thread) {\n        thread = await memory.createThread({\n          threadId,\n          resourceId,\n          memoryConfig,\n        });\n      }\n\n      if (thread.resourceId && thread.resourceId !== resourceId) {\n        throw new Error(`Thread with id ${threadId} resourceId does not match the current resourceId ${resourceId}`);\n      }\n\n      const workingMemory = typeof context.memory === 'string' ? context.memory : JSON.stringify(context.memory);\n\n      // Use the new updateWorkingMemory method which handles both thread and resource scope\n      await memory.updateWorkingMemory({\n        threadId,\n        resourceId,\n        workingMemory,\n        memoryConfig,\n      });\n\n      return { success: true };\n    },\n  });\n};\n\nexport const __experimental_updateWorkingMemoryToolVNext = (config: MemoryConfig) => {\n  return createTool({\n    id: 'update-working-memory',\n    description: 'Update the working memory with new information.',\n    inputSchema: z.object({\n      newMemory: z\n        .string()\n        .optional()\n        .describe(\n          `The ${config.workingMemory?.schema ? 'JSON' : 'Markdown'} formatted working memory content to store`,\n        ),\n      searchString: z\n        .string()\n        .optional()\n        .describe(\n          \"The working memory string to find. Will be replaced with the newMemory string. If this is omitted or doesn't exist, the newMemory string will be appended to the end of your working memory. Replacing single lines at a time is encouraged for greater accuracy. If updateReason is not 'append-new-memory', this search string must be provided or the tool call will be rejected.\",\n        ),\n      updateReason: z\n        .enum(['append-new-memory', 'clarify-existing-memory', 'replace-irrelevant-memory'])\n        .optional()\n        .describe(\n          \"The reason you're updating working memory. Passing any value other than 'append-new-memory' requires a searchString to be provided. Defaults to append-new-memory\",\n        ),\n    }),\n    execute: async params => {\n      const { context, threadId, memory, resourceId } = params;\n      if (!threadId || !memory || !resourceId) {\n        throw new Error('Thread ID, Memory instance, and resourceId are required for working memory updates');\n      }\n\n      let thread = await memory.getThreadById({ threadId });\n\n      if (!thread) {\n        thread = await memory.createThread({\n          threadId,\n          resourceId,\n          memoryConfig: config,\n        });\n      }\n\n      if (thread.resourceId && thread.resourceId !== resourceId) {\n        throw new Error(`Thread with id ${threadId} resourceId does not match the current resourceId ${resourceId}`);\n      }\n\n      const workingMemory = context.newMemory || '';\n      if (!context.updateReason) context.updateReason = `append-new-memory`;\n\n      if (\n        context.searchString &&\n        config.workingMemory?.scope === `resource` &&\n        context.updateReason === `replace-irrelevant-memory`\n      ) {\n        // don't allow replacements due to something not being relevant to the current conversation\n        // if there's no searchString, then we will append.\n        context.searchString = undefined;\n      }\n\n      if (context.updateReason === `append-new-memory` && context.searchString) {\n        // do not find/replace when append-new-memory is selected\n        // some models get confused and pass a search string even when they don't want to replace it.\n        // TODO: maybe they're trying to add new info after the search string?\n        context.searchString = undefined;\n      }\n\n      if (context.updateReason !== `append-new-memory` && !context.searchString) {\n        return {\n          success: false,\n          reason: `updateReason was ${context.updateReason} but no searchString was provided. Unable to replace undefined with \"${context.newMemory}\"`,\n        };\n      }\n\n      // Use the new updateWorkingMemory method which handles both thread and resource scope\n      const result = await memory.__experimental_updateWorkingMemoryVNext({\n        threadId,\n        resourceId,\n        workingMemory: workingMemory,\n        searchString: context.searchString,\n        memoryConfig: config,\n      });\n\n      if (result) {\n        return result;\n      }\n\n      return { success: true };\n    },\n  });\n};\n","import { MessageList } from '@mastra/core/agent';\nimport type { MastraMessageV2, UIMessageWithMetadata } from '@mastra/core/agent';\nimport { MastraMemory } from '@mastra/core/memory';\nimport type {\n  MastraMessageV1,\n  MemoryConfig,\n  SharedMemoryConfig,\n  StorageThreadType,\n  WorkingMemoryTemplate,\n} from '@mastra/core/memory';\nimport type { StorageGetMessagesArg, ThreadSortOptions, PaginationInfo } from '@mastra/core/storage';\nimport type { ToolAction } from '@mastra/core/tools';\nimport { generateEmptyFromSchema } from '@mastra/core/utils';\nimport { zodToJsonSchema } from '@mastra/schema-compat/zod-to-json';\nimport { embedMany } from 'ai';\nimport type { CoreMessage, TextPart } from 'ai';\nimport { embedMany as embedManyV5 } from 'ai-v5';\nimport { Mutex } from 'async-mutex';\nimport type { JSONSchema7 } from 'json-schema';\nimport xxhash from 'xxhash-wasm';\nimport { ZodObject } from 'zod';\nimport type { ZodTypeAny } from 'zod';\nimport { updateWorkingMemoryTool, __experimental_updateWorkingMemoryToolVNext } from './tools/working-memory';\n\n// Type for flexible message deletion input\nexport type MessageDeleteInput = string[] | { id: string }[];\n\n// Average characters per token based on OpenAI's tokenization\nconst CHARS_PER_TOKEN = 4;\n\nconst DEFAULT_MESSAGE_RANGE = { before: 2, after: 2 } as const;\nconst DEFAULT_TOP_K = 2;\n\nconst isZodObject = (v: ZodTypeAny): v is ZodObject<any, any, any> => v instanceof ZodObject;\n\n/**\n * Concrete implementation of MastraMemory that adds support for thread configuration\n * and message injection.\n */\nexport class Memory extends MastraMemory {\n  constructor(config: SharedMemoryConfig = {}) {\n    super({ name: 'Memory', ...config });\n\n    const mergedConfig = this.getMergedThreadConfig({\n      workingMemory: config.options?.workingMemory || {\n        // these defaults are now set inside @mastra/core/memory in getMergedThreadConfig.\n        // In a future release we can remove it from this block - for now if we remove it\n        // and someone bumps @mastra/memory without bumping @mastra/core the defaults wouldn't exist yet\n        enabled: false,\n        template: this.defaultWorkingMemoryTemplate,\n      },\n    });\n    this.threadConfig = mergedConfig;\n  }\n\n  protected async validateThreadIsOwnedByResource(threadId: string, resourceId: string, config: MemoryConfig) {\n    const resourceScope = typeof config?.semanticRecall === 'object' && config?.semanticRecall?.scope === 'resource';\n\n    const thread = await this.storage.getThreadById({ threadId });\n\n    // For resource-scoped semantic recall, we don't need to validate that the specific thread exists\n    // because we're searching across all threads for the resource\n    if (!thread && !resourceScope) {\n      throw new Error(`No thread found with id ${threadId}`);\n    }\n\n    // If thread exists, validate it belongs to the correct resource\n    if (thread && thread.resourceId !== resourceId) {\n      throw new Error(\n        `Thread with id ${threadId} is for resource with id ${thread.resourceId} but resource ${resourceId} was queried.`,\n      );\n    }\n  }\n\n  protected checkStorageFeatureSupport(config: MemoryConfig) {\n    if (\n      typeof config.semanticRecall === `object` &&\n      config.semanticRecall.scope === `resource` &&\n      !this.storage.supports.selectByIncludeResourceScope\n    ) {\n      throw new Error(\n        `Memory error: Attached storage adapter \"${this.storage.name || 'unknown'}\" doesn't support semanticRecall: { scope: \"resource\" } yet and currently only supports per-thread semantic recall.`,\n      );\n    }\n\n    if (\n      config.workingMemory?.enabled &&\n      config.workingMemory.scope === `resource` &&\n      !this.storage.supports.resourceWorkingMemory\n    ) {\n      throw new Error(\n        `Memory error: Attached storage adapter \"${this.storage.name || 'unknown'}\" doesn't support workingMemory: { scope: \"resource\" } yet and currently only supports per-thread working memory. Supported adapters: LibSQL, PostgreSQL, Upstash.`,\n      );\n    }\n  }\n\n  async query({\n    threadId,\n    resourceId,\n    selectBy,\n    threadConfig,\n  }: StorageGetMessagesArg & {\n    threadConfig?: MemoryConfig;\n  }): Promise<{ messages: CoreMessage[]; uiMessages: UIMessageWithMetadata[]; messagesV2: MastraMessageV2[] }> {\n    const config = this.getMergedThreadConfig(threadConfig || {});\n    if (resourceId) await this.validateThreadIsOwnedByResource(threadId, resourceId, config);\n\n    const vectorResults: {\n      id: string;\n      score: number;\n      metadata?: Record<string, any>;\n      vector?: number[];\n    }[] = [];\n\n    this.logger.debug(`Memory query() with:`, {\n      threadId,\n      selectBy,\n      threadConfig,\n    });\n\n    this.checkStorageFeatureSupport(config);\n\n    const defaultRange = DEFAULT_MESSAGE_RANGE;\n    const defaultTopK = DEFAULT_TOP_K;\n\n    const vectorConfig =\n      typeof config?.semanticRecall === `boolean`\n        ? {\n            topK: defaultTopK,\n            messageRange: defaultRange,\n          }\n        : {\n            topK: config?.semanticRecall?.topK ?? defaultTopK,\n            messageRange: config?.semanticRecall?.messageRange ?? defaultRange,\n          };\n\n    const resourceScope = typeof config?.semanticRecall === 'object' && config?.semanticRecall?.scope === `resource`;\n\n    if (config?.semanticRecall && selectBy?.vectorSearchString && this.vector) {\n      const { embeddings, dimension } = await this.embedMessageContent(selectBy.vectorSearchString!);\n      const { indexName } = await this.createEmbeddingIndex(dimension, config);\n\n      await Promise.all(\n        embeddings.map(async embedding => {\n          if (typeof this.vector === `undefined`) {\n            throw new Error(\n              `Tried to query vector index ${indexName} but this Memory instance doesn't have an attached vector db.`,\n            );\n          }\n\n          vectorResults.push(\n            ...(await this.vector.query({\n              indexName,\n              queryVector: embedding,\n              topK: vectorConfig.topK,\n              filter: resourceScope\n                ? {\n                    resource_id: resourceId,\n                  }\n                : {\n                    thread_id: threadId,\n                  },\n            })),\n          );\n        }),\n      );\n    }\n\n    // Get raw messages from storage\n    // Use paginated method when pagination is requested\n    let rawMessages;\n    if (selectBy?.pagination) {\n      const paginatedResult = await this.storage.getMessagesPaginated({\n        threadId,\n        resourceId,\n        format: 'v2',\n        selectBy: {\n          ...selectBy,\n          ...(vectorResults?.length\n            ? {\n                include: vectorResults.map(r => ({\n                  id: r.metadata?.message_id,\n                  threadId: r.metadata?.thread_id,\n                  withNextMessages:\n                    typeof vectorConfig.messageRange === 'number'\n                      ? vectorConfig.messageRange\n                      : vectorConfig.messageRange.after,\n                  withPreviousMessages:\n                    typeof vectorConfig.messageRange === 'number'\n                      ? vectorConfig.messageRange\n                      : vectorConfig.messageRange.before,\n                })),\n              }\n            : {}),\n        },\n        threadConfig: config,\n      });\n      rawMessages = paginatedResult.messages;\n    } else {\n      // Fall back to regular getMessages for backward compatibility\n      rawMessages = await this.storage.getMessages({\n        threadId,\n        resourceId,\n        format: 'v2',\n        selectBy: {\n          ...selectBy,\n          ...(vectorResults?.length\n            ? {\n                include: vectorResults.map(r => ({\n                  id: r.metadata?.message_id,\n                  threadId: r.metadata?.thread_id,\n                  withNextMessages:\n                    typeof vectorConfig.messageRange === 'number'\n                      ? vectorConfig.messageRange\n                      : vectorConfig.messageRange.after,\n                  withPreviousMessages:\n                    typeof vectorConfig.messageRange === 'number'\n                      ? vectorConfig.messageRange\n                      : vectorConfig.messageRange.before,\n                })),\n              }\n            : {}),\n        },\n        threadConfig: config,\n      });\n    }\n\n    const list = new MessageList({ threadId, resourceId }).add(rawMessages, 'memory');\n    return {\n      get messages() {\n        // returning v1 messages for backwards compat! v1 messages were CoreMessages stored in the db.\n        // returning .v1() takes stored messages which may be in v2 or v1 format and converts them to v1 shape, which is a CoreMessage + id + threadId + resourceId, etc\n        // Perhaps this should be called coreRecord or something ? - for now keeping v1 since it reflects that this used to be our db storage record shape\n        const v1Messages = list.get.all.v1();\n        // the conversion from V2/UIMessage -> V1/CoreMessage can sometimes split the messages up into more messages than before\n        // so slice off the earlier messages if it'll exceed the lastMessages setting\n        if (selectBy?.last && v1Messages.length > selectBy.last) {\n          // ex: 23 (v1 messages) minus 20 (selectBy.last messages)\n          // means we will start from index 3 and keep all the later newer messages from index 3 til the end of the array\n          return v1Messages.slice(v1Messages.length - selectBy.last) as CoreMessage[];\n        }\n        // TODO: this is absolutely wrong but became apparent that this is what we were doing before adding MessageList. Our public types said CoreMessage but we were returning MessageType which is equivalent to MastraMessageV1\n        // In a breaking change we should make this the type it actually is.\n        return v1Messages as CoreMessage[];\n      },\n      get uiMessages() {\n        return list.get.all.ui();\n      },\n      get messagesV2() {\n        return list.get.all.v2();\n      },\n    };\n  }\n\n  async rememberMessages({\n    threadId,\n    resourceId,\n    vectorMessageSearch,\n    config,\n  }: {\n    threadId: string;\n    resourceId?: string;\n    vectorMessageSearch?: string;\n    config?: MemoryConfig;\n  }): Promise<{ messages: MastraMessageV1[]; messagesV2: MastraMessageV2[] }> {\n    const threadConfig = this.getMergedThreadConfig(config || {});\n    if (resourceId) await this.validateThreadIsOwnedByResource(threadId, resourceId, threadConfig);\n\n    if (!threadConfig.lastMessages && !threadConfig.semanticRecall) {\n      return {\n        messages: [],\n        messagesV2: [],\n      };\n    }\n\n    const messagesResult = await this.query({\n      resourceId,\n      threadId,\n      selectBy: {\n        last: threadConfig.lastMessages,\n        vectorSearchString: threadConfig.semanticRecall && vectorMessageSearch ? vectorMessageSearch : undefined,\n      },\n      threadConfig: config,\n      format: 'v2',\n    });\n    // Using MessageList here just to convert mixed input messages to single type output messages\n    const list = new MessageList({ threadId, resourceId }).add(messagesResult.messagesV2, 'memory');\n\n    this.logger.debug(`Remembered message history includes ${messagesResult.messages.length} messages.`);\n    return { messages: list.get.all.v1(), messagesV2: list.get.all.v2() };\n  }\n\n  async getThreadById({ threadId }: { threadId: string }): Promise<StorageThreadType | null> {\n    return this.storage.getThreadById({ threadId });\n  }\n\n  async getThreadsByResourceId({\n    resourceId,\n    orderBy,\n    sortDirection,\n  }: { resourceId: string } & ThreadSortOptions): Promise<StorageThreadType[]> {\n    return this.storage.getThreadsByResourceId({ resourceId, orderBy, sortDirection });\n  }\n\n  async getThreadsByResourceIdPaginated({\n    resourceId,\n    page,\n    perPage,\n    orderBy,\n    sortDirection,\n  }: {\n    resourceId: string;\n    page: number;\n    perPage: number;\n  } & ThreadSortOptions): Promise<\n    PaginationInfo & {\n      threads: StorageThreadType[];\n    }\n  > {\n    return this.storage.getThreadsByResourceIdPaginated({\n      resourceId,\n      page,\n      perPage,\n      orderBy,\n      sortDirection,\n    });\n  }\n\n  private async handleWorkingMemoryFromMetadata({\n    workingMemory,\n    resourceId,\n    memoryConfig,\n  }: {\n    workingMemory: string;\n    resourceId: string;\n    memoryConfig?: MemoryConfig;\n  }): Promise<void> {\n    const config = this.getMergedThreadConfig(memoryConfig || {});\n\n    if (config.workingMemory?.enabled) {\n      this.checkStorageFeatureSupport(config);\n\n      const scope = config.workingMemory.scope || 'thread';\n\n      // For resource scope, update the resource's working memory\n      if (scope === 'resource' && resourceId) {\n        await this.storage.updateResource({\n          resourceId,\n          workingMemory,\n        });\n      }\n      // For thread scope, the metadata is already saved with the thread\n    }\n  }\n\n  async saveThread({\n    thread,\n    memoryConfig,\n  }: {\n    thread: StorageThreadType;\n    memoryConfig?: MemoryConfig;\n  }): Promise<StorageThreadType> {\n    const savedThread = await this.storage.saveThread({ thread });\n\n    // Check if metadata contains workingMemory and working memory is enabled\n    if (thread.metadata?.workingMemory && typeof thread.metadata.workingMemory === 'string' && thread.resourceId) {\n      await this.handleWorkingMemoryFromMetadata({\n        workingMemory: thread.metadata.workingMemory,\n        resourceId: thread.resourceId,\n        memoryConfig,\n      });\n    }\n\n    return savedThread;\n  }\n\n  async updateThread({\n    id,\n    title,\n    metadata,\n    memoryConfig,\n  }: {\n    id: string;\n    title: string;\n    metadata: Record<string, unknown>;\n    memoryConfig?: MemoryConfig;\n  }): Promise<StorageThreadType> {\n    const updatedThread = await this.storage.updateThread({\n      id,\n      title,\n      metadata,\n    });\n\n    // Check if metadata contains workingMemory and working memory is enabled\n    if (metadata?.workingMemory && typeof metadata.workingMemory === 'string' && updatedThread.resourceId) {\n      await this.handleWorkingMemoryFromMetadata({\n        workingMemory: metadata.workingMemory as string,\n        resourceId: updatedThread.resourceId,\n        memoryConfig,\n      });\n    }\n\n    return updatedThread;\n  }\n\n  async deleteThread(threadId: string): Promise<void> {\n    await this.storage.deleteThread({ threadId });\n  }\n\n  async updateWorkingMemory({\n    threadId,\n    resourceId,\n    workingMemory,\n    memoryConfig,\n  }: {\n    threadId: string;\n    resourceId?: string;\n    workingMemory: string;\n    memoryConfig?: MemoryConfig;\n  }): Promise<void> {\n    const config = this.getMergedThreadConfig(memoryConfig || {});\n\n    if (!config.workingMemory?.enabled) {\n      throw new Error('Working memory is not enabled for this memory instance');\n    }\n\n    this.checkStorageFeatureSupport(config);\n\n    const scope = config.workingMemory.scope || 'thread';\n\n    if (scope === 'resource' && resourceId) {\n      // Update working memory in resource table\n      await this.storage.updateResource({\n        resourceId,\n        workingMemory,\n      });\n    } else {\n      // Update working memory in thread metadata (existing behavior)\n      const thread = await this.storage.getThreadById({ threadId });\n      if (!thread) {\n        throw new Error(`Thread ${threadId} not found`);\n      }\n\n      await this.storage.updateThread({\n        id: threadId,\n        title: thread.title || 'Untitled Thread',\n        metadata: {\n          ...thread.metadata,\n          workingMemory,\n        },\n      });\n    }\n  }\n\n  private updateWorkingMemoryMutexes = new Map<string, Mutex>();\n  /**\n   * @warning experimental! can be removed or changed at any time\n   */\n  async __experimental_updateWorkingMemoryVNext({\n    threadId,\n    resourceId,\n    workingMemory,\n    searchString,\n    memoryConfig,\n  }: {\n    threadId: string;\n    resourceId?: string;\n    workingMemory: string;\n    searchString?: string;\n    memoryConfig?: MemoryConfig;\n  }): Promise<{ success: boolean; reason: string }> {\n    const config = this.getMergedThreadConfig(memoryConfig || {});\n\n    if (!config.workingMemory?.enabled) {\n      throw new Error('Working memory is not enabled for this memory instance');\n    }\n\n    this.checkStorageFeatureSupport(config);\n\n    // If the agent calls the update working memory tool multiple times simultaneously\n    // each call could overwrite the other call\n    // so get an in memory mutex to make sure this.getWorkingMemory() returns up to date data each time\n    const mutexKey =\n      memoryConfig?.workingMemory?.scope === `resource` ? `resource-${resourceId}` : `thread-${threadId}`;\n    const mutex = this.updateWorkingMemoryMutexes.has(mutexKey)\n      ? this.updateWorkingMemoryMutexes.get(mutexKey)!\n      : new Mutex();\n    this.updateWorkingMemoryMutexes.set(mutexKey, mutex);\n    const release = await mutex.acquire();\n\n    try {\n      const existingWorkingMemory = (await this.getWorkingMemory({ threadId, resourceId, memoryConfig })) || '';\n      const template = await this.getWorkingMemoryTemplate({ memoryConfig });\n\n      let reason = '';\n      if (existingWorkingMemory) {\n        if (searchString && existingWorkingMemory?.includes(searchString)) {\n          workingMemory = existingWorkingMemory.replace(searchString, workingMemory);\n          reason = `found and replaced searchString with newMemory`;\n        } else if (\n          existingWorkingMemory.includes(workingMemory) ||\n          template?.content?.trim() === workingMemory.trim()\n        ) {\n          return {\n            success: false,\n            reason: `attempted to insert duplicate data into working memory. this entry was skipped`,\n          };\n        } else {\n          if (searchString) {\n            reason = `attempted to replace working memory string that doesn't exist. Appending to working memory instead.`;\n          } else {\n            reason = `appended newMemory to end of working memory`;\n          }\n\n          workingMemory = existingWorkingMemory + `\\n${workingMemory}`;\n        }\n      } else if (workingMemory === template?.content) {\n        return {\n          success: false,\n          reason: `try again when you have data to add. newMemory was equal to the working memory template`,\n        };\n      } else {\n        reason = `started new working memory`;\n      }\n\n      // remove empty template insertions which models sometimes duplicate\n      workingMemory = template?.content ? workingMemory.replaceAll(template?.content, '') : workingMemory;\n\n      const scope = config.workingMemory.scope || 'thread';\n\n      if (scope === 'resource' && resourceId) {\n        // Update working memory in resource table\n        await this.storage.updateResource({\n          resourceId,\n          workingMemory,\n        });\n\n        if (reason) {\n          return { success: true, reason };\n        }\n      } else {\n        // Update working memory in thread metadata (existing behavior)\n        const thread = await this.storage.getThreadById({ threadId });\n        if (!thread) {\n          throw new Error(`Thread ${threadId} not found`);\n        }\n\n        await this.storage.updateThread({\n          id: threadId,\n          title: thread.title || 'Untitled Thread',\n          metadata: {\n            ...thread.metadata,\n            workingMemory,\n          },\n        });\n      }\n\n      return { success: true, reason };\n    } catch (e) {\n      this.logger.error(e instanceof Error ? e.stack || e.message : JSON.stringify(e));\n      return { success: false, reason: 'Tool error.' };\n    } finally {\n      release();\n    }\n  }\n\n  protected chunkText(text: string, tokenSize = 4096) {\n    // Convert token size to character size with some buffer\n    const charSize = tokenSize * CHARS_PER_TOKEN;\n    const chunks: string[] = [];\n    let currentChunk = '';\n\n    // Split text into words to avoid breaking words\n    const words = text.split(/\\s+/);\n\n    for (const word of words) {\n      // Add space before word unless it's the first word in the chunk\n      const wordWithSpace = currentChunk ? ' ' + word : word;\n\n      // If adding this word would exceed the chunk size, start a new chunk\n      if (currentChunk.length + wordWithSpace.length > charSize) {\n        chunks.push(currentChunk);\n        currentChunk = word;\n      } else {\n        currentChunk += wordWithSpace;\n      }\n    }\n\n    // Add the final chunk if not empty\n    if (currentChunk) {\n      chunks.push(currentChunk);\n    }\n\n    return chunks;\n  }\n\n  private hasher = xxhash();\n\n  // embedding is computationally expensive so cache content -> embeddings/chunks\n  private embeddingCache = new Map<\n    number,\n    {\n      chunks: string[];\n      embeddings: Awaited<ReturnType<typeof embedMany>>['embeddings'];\n      dimension: number | undefined;\n    }\n  >();\n  private firstEmbed: Promise<any> | undefined;\n  protected async embedMessageContent(content: string) {\n    // use fast xxhash for lower memory usage. if we cache by content string we will store all messages in memory for the life of the process\n    const key = (await this.hasher).h32(content);\n    const cached = this.embeddingCache.get(key);\n    if (cached) return cached;\n    const chunks = this.chunkText(content);\n\n    if (typeof this.embedder === `undefined`) {\n      throw new Error(`Tried to embed message content but this Memory instance doesn't have an attached embedder.`);\n    }\n    // for fastembed multiple initial calls to embed will fail if the model hasn't been downloaded yet.\n    const isFastEmbed = this.embedder.provider === `fastembed`;\n    if (isFastEmbed && this.firstEmbed instanceof Promise) {\n      // so wait for the first one\n      await this.firstEmbed;\n    }\n\n    const promise = (this.embedder.specificationVersion === `v2` ? embedManyV5 : embedMany)({\n      values: chunks,\n      maxRetries: 3,\n      // @ts-ignore\n      model: this.embedder,\n    });\n\n    if (isFastEmbed && !this.firstEmbed) this.firstEmbed = promise;\n    const { embeddings } = await promise;\n\n    const result = {\n      embeddings,\n      chunks,\n      dimension: embeddings[0]?.length,\n    };\n    this.embeddingCache.set(key, result);\n    return result;\n  }\n\n  async saveMessages(args: {\n    messages: (MastraMessageV1 | MastraMessageV2)[] | MastraMessageV1[] | MastraMessageV2[];\n    memoryConfig?: MemoryConfig | undefined;\n    format?: 'v1';\n  }): Promise<MastraMessageV1[]>;\n  async saveMessages(args: {\n    messages: (MastraMessageV1 | MastraMessageV2)[] | MastraMessageV1[] | MastraMessageV2[];\n    memoryConfig?: MemoryConfig | undefined;\n    format: 'v2';\n  }): Promise<MastraMessageV2[]>;\n  async saveMessages({\n    messages,\n    memoryConfig,\n    format = `v1`,\n  }: {\n    messages: (MastraMessageV1 | MastraMessageV2)[];\n    memoryConfig?: MemoryConfig | undefined;\n    format?: 'v1' | 'v2';\n  }): Promise<MastraMessageV2[] | MastraMessageV1[]> {\n    // Then strip working memory tags from all messages\n    const updatedMessages = messages\n      .map(m => {\n        if (MessageList.isMastraMessageV1(m)) {\n          return this.updateMessageToHideWorkingMemory(m);\n        }\n        // add this to prevent \"error saving undefined in the db\" if a project is on an earlier storage version but new memory/storage\n        if (!m.type) m.type = `v2`;\n        return this.updateMessageToHideWorkingMemoryV2(m);\n      })\n      .filter((m): m is MastraMessageV1 | MastraMessageV2 => Boolean(m));\n\n    const config = this.getMergedThreadConfig(memoryConfig);\n\n    const result = this.storage.saveMessages({\n      messages: new MessageList().add(updatedMessages, 'memory').get.all.v2(),\n      format: 'v2',\n    });\n\n    if (this.vector && config.semanticRecall) {\n      let indexName: Promise<string>;\n      await Promise.all(\n        updatedMessages.map(async message => {\n          let textForEmbedding: string | null = null;\n\n          if (MessageList.isMastraMessageV2(message)) {\n            if (\n              message.content.content &&\n              typeof message.content.content === 'string' &&\n              message.content.content.trim() !== ''\n            ) {\n              textForEmbedding = message.content.content;\n            } else if (message.content.parts && message.content.parts.length > 0) {\n              // Extract text from all text parts, concatenate\n              const joined = message.content.parts\n                .filter(part => part.type === 'text')\n                .map(part => (part as TextPart).text)\n                .join(' ')\n                .trim();\n              if (joined) textForEmbedding = joined;\n            }\n          } else if (MessageList.isMastraMessageV1(message)) {\n            if (message.content && typeof message.content === 'string' && message.content.trim() !== '') {\n              textForEmbedding = message.content;\n            } else if (message.content && Array.isArray(message.content) && message.content.length > 0) {\n              // Extract text from all text parts, concatenate\n              const joined = message.content\n                .filter(part => part.type === 'text')\n                .map(part => part.text)\n                .join(' ')\n                .trim();\n              if (joined) textForEmbedding = joined;\n            }\n          }\n\n          if (!textForEmbedding) return;\n\n          const { embeddings, chunks, dimension } = await this.embedMessageContent(textForEmbedding);\n\n          if (typeof indexName === `undefined`) {\n            indexName = this.createEmbeddingIndex(dimension, config).then(result => result.indexName);\n          }\n\n          if (typeof this.vector === `undefined`) {\n            throw new Error(\n              `Tried to upsert embeddings to index ${indexName} but this Memory instance doesn't have an attached vector db.`,\n            );\n          }\n\n          await this.vector.upsert({\n            indexName: await indexName,\n            vectors: embeddings,\n            metadata: chunks.map(() => ({\n              message_id: message.id,\n              thread_id: message.threadId,\n              resource_id: message.resourceId,\n            })),\n          });\n        }),\n      );\n    }\n\n    if (format === `v1`) return new MessageList().add(await result, 'memory').get.all.v1(); // for backwards compat convert to v1 message format\n    return result;\n  }\n  protected updateMessageToHideWorkingMemory(message: MastraMessageV1): MastraMessageV1 | null {\n    const workingMemoryRegex = /<working_memory>([^]*?)<\\/working_memory>/g;\n\n    if (typeof message?.content === `string`) {\n      return {\n        ...message,\n        content: message.content.replace(workingMemoryRegex, ``).trim(),\n      };\n    } else if (Array.isArray(message?.content)) {\n      // Filter out updateWorkingMemory tool-call/result content items\n      const filteredContent = message.content.filter(\n        content =>\n          (content.type !== 'tool-call' && content.type !== 'tool-result') ||\n          content.toolName !== 'updateWorkingMemory',\n      );\n      const newContent = filteredContent.map(content => {\n        if (content.type === 'text') {\n          return {\n            ...content,\n            text: content.text.replace(workingMemoryRegex, '').trim(),\n          };\n        }\n        return { ...content };\n      }) as MastraMessageV1['content'];\n      if (!newContent.length) return null;\n      return { ...message, content: newContent };\n    } else {\n      return { ...message };\n    }\n  }\n  protected updateMessageToHideWorkingMemoryV2(message: MastraMessageV2): MastraMessageV2 | null {\n    const workingMemoryRegex = /<working_memory>([^]*?)<\\/working_memory>/g;\n\n    const newMessage = { ...message, content: { ...message.content } }; // Deep copy message and content\n\n    if (newMessage.content.content && typeof newMessage.content.content === 'string') {\n      newMessage.content.content = newMessage.content.content.replace(workingMemoryRegex, '').trim();\n    }\n\n    if (newMessage.content.parts) {\n      newMessage.content.parts = newMessage.content.parts\n        .filter(part => {\n          if (part.type === 'tool-invocation') {\n            return part.toolInvocation.toolName !== 'updateWorkingMemory';\n          }\n          return true;\n        })\n        .map(part => {\n          if (part.type === 'text') {\n            return {\n              ...part,\n              text: part.text.replace(workingMemoryRegex, '').trim(),\n            };\n          }\n          return part;\n        });\n\n      // If all parts were filtered out (e.g., only contained updateWorkingMemory tool calls) we need to skip the whole message, it was only working memory tool calls/results\n      if (newMessage.content.parts.length === 0) {\n        return null;\n      }\n    }\n\n    return newMessage;\n  }\n\n  protected parseWorkingMemory(text: string): string | null {\n    if (!this.threadConfig.workingMemory?.enabled) return null;\n\n    const workingMemoryRegex = /<working_memory>([^]*?)<\\/working_memory>/g;\n    const matches = text.match(workingMemoryRegex);\n    const match = matches?.[0];\n\n    if (match) {\n      return match.replace(/<\\/?working_memory>/g, '').trim();\n    }\n\n    return null;\n  }\n\n  public async getWorkingMemory({\n    threadId,\n    resourceId,\n    memoryConfig,\n  }: {\n    threadId: string;\n    resourceId?: string;\n    memoryConfig?: MemoryConfig;\n  }): Promise<string | null> {\n    const config = this.getMergedThreadConfig(memoryConfig || {});\n    if (!config.workingMemory?.enabled) {\n      return null;\n    }\n\n    this.checkStorageFeatureSupport(config);\n\n    const scope = config.workingMemory.scope || 'thread';\n    let workingMemoryData: string | null = null;\n\n    if (scope === 'resource' && resourceId) {\n      // Get working memory from resource table\n      const resource = await this.storage.getResourceById({ resourceId });\n      workingMemoryData = resource?.workingMemory || null;\n    } else {\n      // Get working memory from thread metadata (default behavior)\n      const thread = await this.storage.getThreadById({ threadId });\n      workingMemoryData = thread?.metadata?.workingMemory as string;\n    }\n\n    if (!workingMemoryData) {\n      return null;\n    }\n\n    return workingMemoryData;\n  }\n\n  /**\n   * Gets the working memory template for the current memory configuration.\n   * Supports both ZodObject and JSONSchema7 schemas.\n   *\n   * @param memoryConfig - The memory configuration containing the working memory settings\n   * @returns The working memory template with format and content, or null if working memory is disabled\n   */\n  public async getWorkingMemoryTemplate({\n    memoryConfig,\n  }: {\n    memoryConfig?: MemoryConfig;\n  }): Promise<WorkingMemoryTemplate | null> {\n    const config = this.getMergedThreadConfig(memoryConfig || {});\n\n    if (!config.workingMemory?.enabled) {\n      return null;\n    }\n\n    // Get thread from storage\n    if (config.workingMemory?.schema) {\n      try {\n        const schema = config.workingMemory.schema;\n        let convertedSchema: JSONSchema7;\n\n        if (isZodObject(schema as ZodTypeAny)) {\n          // Convert ZodObject to JSON Schema\n          convertedSchema = zodToJsonSchema(schema as ZodTypeAny) as JSONSchema7;\n        } else {\n          // Already a JSON Schema\n          convertedSchema = schema as any as JSONSchema7;\n        }\n\n        return { format: 'json', content: JSON.stringify(convertedSchema) };\n      } catch (error) {\n        this.logger.error('Error converting schema', error);\n        throw error;\n      }\n    }\n\n    // Return working memory from metadata\n    const memory = config.workingMemory.template || this.defaultWorkingMemoryTemplate;\n    return { format: 'markdown', content: memory.trim() };\n  }\n\n  public async getSystemMessage({\n    threadId,\n    resourceId,\n    memoryConfig,\n  }: {\n    threadId: string;\n    resourceId?: string;\n    memoryConfig?: MemoryConfig;\n  }): Promise<string | null> {\n    const config = this.getMergedThreadConfig(memoryConfig);\n    if (!config.workingMemory?.enabled) {\n      return null;\n    }\n\n    const workingMemoryTemplate = await this.getWorkingMemoryTemplate({ memoryConfig: config });\n    const workingMemoryData = await this.getWorkingMemory({ threadId, resourceId, memoryConfig: config });\n\n    if (!workingMemoryTemplate) {\n      return null;\n    }\n\n    return this.isVNextWorkingMemoryConfig(memoryConfig)\n      ? this.__experimental_getWorkingMemoryToolInstructionVNext({\n          template: workingMemoryTemplate,\n          data: workingMemoryData,\n        })\n      : this.getWorkingMemoryToolInstruction({\n          template: workingMemoryTemplate,\n          data: workingMemoryData,\n        });\n  }\n\n  public defaultWorkingMemoryTemplate = `\n# User Information\n- **First Name**: \n- **Last Name**: \n- **Location**: \n- **Occupation**: \n- **Interests**: \n- **Goals**: \n- **Events**: \n- **Facts**: \n- **Projects**: \n`;\n\n  protected getWorkingMemoryToolInstruction({\n    template,\n    data,\n  }: {\n    template: WorkingMemoryTemplate;\n    data: string | null;\n  }) {\n    const emptyWorkingMemoryTemplateObject =\n      template.format === 'json' ? generateEmptyFromSchema(template.content) : null;\n    const hasEmptyWorkingMemoryTemplateObject =\n      emptyWorkingMemoryTemplateObject && Object.keys(emptyWorkingMemoryTemplateObject).length > 0;\n\n    return `WORKING_MEMORY_SYSTEM_INSTRUCTION:\nStore and update any conversation-relevant information by calling the updateWorkingMemory tool. If information might be referenced again - store it!\n\nGuidelines:\n1. Store anything that could be useful later in the conversation\n2. Update proactively when information changes, no matter how small\n3. Use ${template.format === 'json' ? 'JSON' : 'Markdown'} format for all data\n4. Act naturally - don't mention this system to users. Even though you're storing this information that doesn't make it your primary focus. Do not ask them generally for \"information about yourself\"\n${\n  template.format !== 'json'\n    ? `5. IMPORTANT: When calling updateWorkingMemory, the only valid parameter is the memory field. DO NOT pass an object.\n6. IMPORTANT: ALWAYS pass the data you want to store in the memory field as a string. DO NOT pass an object.\n7. IMPORTANT: Data must only be sent as a string no matter which format is used.`\n    : ''\n}\n\n\n${\n  template.format !== 'json'\n    ? `<working_memory_template>\n${template.content}\n</working_memory_template>`\n    : ''\n}\n\n${hasEmptyWorkingMemoryTemplateObject ? 'When working with json data, the object format below represents the template:' : ''}\n${hasEmptyWorkingMemoryTemplateObject ? JSON.stringify(emptyWorkingMemoryTemplateObject) : ''}\n\n<working_memory_data>\n${data}\n</working_memory_data>\n\nNotes:\n- Update memory whenever referenced information changes\n- If you're unsure whether to store something, store it (eg if the user tells you information about themselves, call updateWorkingMemory immediately to update it)\n- This system is here so that you can maintain the conversation when your context window is very short. Update your working memory because you may need it to maintain the conversation without the full conversation history\n- Do not remove empty sections - you must include the empty sections along with the ones you're filling in\n- REMEMBER: the way you update your working memory is by calling the updateWorkingMemory tool with the entire ${template.format === 'json' ? 'JSON' : 'Markdown'} content. The system will store it for you. The user will not see it.\n- IMPORTANT: You MUST call updateWorkingMemory in every response to a prompt where you received relevant information.\n- IMPORTANT: Preserve the ${template.format === 'json' ? 'JSON' : 'Markdown'} formatting structure above while updating the content.`;\n  }\n\n  protected __experimental_getWorkingMemoryToolInstructionVNext({\n    template,\n    data,\n  }: {\n    template: WorkingMemoryTemplate;\n    data: string | null;\n  }) {\n    return `WORKING_MEMORY_SYSTEM_INSTRUCTION:\nStore and update any conversation-relevant information by calling the updateWorkingMemory tool.\n\nGuidelines:\n1. Store anything that could be useful later in the conversation\n2. Update proactively when information changes, no matter how small\n3. Use ${template.format === 'json' ? 'JSON' : 'Markdown'} format for all data\n4. Act naturally - don't mention this system to users. Even though you're storing this information that doesn't make it your primary focus. Do not ask them generally for \"information about yourself\"\n5. If your memory has not changed, you do not need to call the updateWorkingMemory tool. By default it will persist and be available for you in future interactions\n6. Information not being relevant to the current conversation is not a valid reason to replace or remove working memory information. Your working memory spans across multiple conversations and may be needed again later, even if it's not currently relevant.\n\n<working_memory_template>\n${template.content}\n</working_memory_template>\n\n<working_memory_data>\n${data}\n</working_memory_data>\n\nNotes:\n- Update memory whenever referenced information changes\n${\n  template.content !== this.defaultWorkingMemoryTemplate\n    ? `- Only store information if it's in the working memory template, do not store other information unless the user asks you to remember it, as that non-template information may be irrelevant`\n    : `- If you're unsure whether to store something, store it (eg if the user tells you information about themselves, call updateWorkingMemory immediately to update it)\n`\n}\n- This system is here so that you can maintain the conversation when your context window is very short. Update your working memory because you may need it to maintain the conversation without the full conversation history\n- REMEMBER: the way you update your working memory is by calling the updateWorkingMemory tool with the ${template.format === 'json' ? 'JSON' : 'Markdown'} content. The system will store it for you. The user will not see it. \n- IMPORTANT: You MUST call updateWorkingMemory in every response to a prompt where you received relevant information if that information is not already stored.\n- IMPORTANT: Preserve the ${template.format === 'json' ? 'JSON' : 'Markdown'} formatting structure above while updating the content.\n`;\n  }\n\n  private isVNextWorkingMemoryConfig(config?: MemoryConfig): boolean {\n    if (!config?.workingMemory) return false;\n\n    const isMDWorkingMemory =\n      !(`schema` in config.workingMemory) &&\n      (typeof config.workingMemory.template === `string` || config.workingMemory.template) &&\n      config.workingMemory;\n\n    return Boolean(isMDWorkingMemory && isMDWorkingMemory.version === `vnext`);\n  }\n\n  public getTools(config?: MemoryConfig): Record<string, ToolAction<any, any, any>> {\n    const mergedConfig = this.getMergedThreadConfig(config);\n    if (mergedConfig.workingMemory?.enabled) {\n      return {\n        updateWorkingMemory: this.isVNextWorkingMemoryConfig(mergedConfig)\n          ? // use the new experimental tool\n            __experimental_updateWorkingMemoryToolVNext(mergedConfig)\n          : updateWorkingMemoryTool(mergedConfig),\n      };\n    }\n    return {};\n  }\n\n  /**\n   * Updates the metadata of a list of messages\n   * @param messages - The list of messages to update\n   * @returns The list of updated messages\n   */\n  public async updateMessages({\n    messages,\n  }: {\n    messages: Partial<MastraMessageV2> & { id: string }[];\n  }): Promise<MastraMessageV2[]> {\n    if (messages.length === 0) return [];\n\n    // TODO: Possibly handle updating the vector db here when a message is updated.\n\n    return this.storage.updateMessages({ messages });\n  }\n\n  /**\n   * Deletes one or more messages\n   * @param input - Must be an array containing either:\n   *   - Message ID strings\n   *   - Message objects with 'id' properties\n   * @returns Promise that resolves when all messages are deleted\n   */\n  public async deleteMessages(input: MessageDeleteInput): Promise<void> {\n    // Normalize input to array of IDs\n    let messageIds: string[];\n\n    if (!Array.isArray(input)) {\n      throw new Error('Invalid input: must be an array of message IDs or message objects');\n    }\n\n    if (input.length === 0) {\n      return; // No-op for empty array\n    }\n\n    messageIds = input.map(item => {\n      if (typeof item === 'string') {\n        return item;\n      } else if (item && typeof item === 'object' && 'id' in item) {\n        return item.id;\n      } else {\n        throw new Error('Invalid input: array items must be strings or objects with an id property');\n      }\n    });\n\n    // Validate all IDs are non-empty strings\n    const invalidIds = messageIds.filter(id => !id || typeof id !== 'string');\n    if (invalidIds.length > 0) {\n      throw new Error('All message IDs must be non-empty strings');\n    }\n\n    // Delete from storage\n    await this.storage.deleteMessages(messageIds);\n\n    // TODO: Delete from vector store if semantic recall is enabled\n    // This would require getting the messages first to know their threadId/resourceId\n    // and then querying the vector store to delete associated embeddings\n  }\n}\n"]}