{"version":3,"sources":["../src/error/utils.ts","../src/error/index.ts"],"names":["ErrorDomain","ErrorCategory"],"mappings":"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","file":"chunk-5NTO7S5I.cjs","sourcesContent":["/**\n * Safely converts an object to a string representation.\n * Uses JSON.stringify first, but falls back to String() if:\n * - JSON.stringify fails (e.g., circular references)\n * - JSON.stringify returns \"{}\" (e.g., Error objects with no enumerable properties)\n */\nexport function safeParseErrorObject(obj: unknown): string {\n  if (typeof obj !== 'object' || obj === null) {\n    return String(obj);\n  }\n\n  try {\n    const stringified = JSON.stringify(obj);\n    // If JSON.stringify returns \"{}\", fall back to String() for better representation\n    if (stringified === '{}') {\n      return String(obj);\n    }\n    return stringified;\n  } catch {\n    // Fallback to String() if JSON.stringify fails (e.g., circular references)\n    return String(obj);\n  }\n}\n\ntype SerializableError = Error & { toJSON: () => Record<string, any> };\n\n/**\n * Safely converts an unknown error to an Error instance.\n */\nexport function getErrorFromUnknown<SERIALIZABLE extends boolean = true>(\n  unknown: unknown,\n  options: {\n    /**\n     * The fallback error message to use if the unknown error cannot be parsed.\n     */\n    fallbackMessage?: string;\n    /**\n     * The maximum depth to parse the cause of the error.\n     */\n    maxDepth?: number;\n    /**\n     * Whether to add .toJSON() method to the error instance to support serialization. (JSON.stringify)\n     * @example\n     * const error = getErrorFromUnknown(new Error('test'), { supportSerialization: true });\n     * JSON.stringify(error) // { message: 'test', name: 'Error', stack: 'Error: test\\n    at ...' }\n     */\n    supportSerialization?: SERIALIZABLE;\n    /**\n     * Whether to include the stack of the error.\n     */\n    includeStack?: boolean;\n  } = {},\n): SERIALIZABLE extends true ? SerializableError : Error {\n  const defaultOptions = {\n    fallbackMessage: 'Unknown error',\n    maxDepth: 5,\n    supportSerialization: true,\n    includeStack: true,\n  };\n  const mergedOptions = options ? { ...defaultOptions, ...options } : defaultOptions;\n  const { fallbackMessage, maxDepth, supportSerialization, includeStack } = mergedOptions;\n\n  if (unknown && unknown instanceof Error) {\n    if (includeStack === false) {\n      unknown.stack = undefined;\n    }\n    if (supportSerialization) {\n      addErrorToJSON(unknown);\n    }\n    return unknown as SERIALIZABLE extends true ? SerializableError : Error;\n  }\n\n  let error: Error | undefined;\n\n  if (unknown && typeof unknown === 'object') {\n    const errorMessage =\n      unknown && 'message' in unknown && typeof unknown.message === 'string'\n        ? unknown.message\n        : safeParseErrorObject(unknown);\n\n    const errorCause =\n      'cause' in unknown && unknown.cause !== undefined\n        ? unknown.cause instanceof Error\n          ? unknown.cause\n          : maxDepth > 0 // Only process cause if we haven't exceeded max depth\n            ? getErrorFromUnknown(unknown.cause, { ...mergedOptions, maxDepth: maxDepth - 1 })\n            : undefined\n        : undefined;\n\n    error = new Error(errorMessage, errorCause ? { cause: errorCause } : undefined);\n\n    const { stack: _, ...propsWithoutStack } = unknown as any;\n    Object.assign(error as Error, propsWithoutStack);\n    if (includeStack) {\n      error.stack = 'stack' in unknown && typeof unknown.stack === 'string' ? unknown.stack : undefined;\n    }\n  } else if (unknown && typeof unknown === 'string') {\n    error = new Error(unknown);\n    error.stack = undefined;\n  } else {\n    error = new Error(fallbackMessage);\n    error.stack = undefined;\n  }\n\n  if (supportSerialization) {\n    addErrorToJSON(error);\n  }\n  return error as SERIALIZABLE extends true ? SerializableError : Error;\n}\n\n/**\n * Adds a toJSON method to an Error instance for proper serialization.\n * Ensures that message, name, stack, cause, and custom properties are all serialized.\n */\nfunction addErrorToJSON(error: Error): void {\n  if ((error as SerializableError).toJSON) {\n    return;\n  }\n\n  // Define toJSON as non-enumerable to avoid interfering with object comparisons\n  Object.defineProperty(error, 'toJSON', {\n    value: function (this: Error) {\n      const json: Record<string, any> = {\n        message: this.message,\n        name: this.name,\n      };\n      if (this.stack !== undefined) {\n        json.stack = this.stack;\n      }\n      if (this.cause !== undefined) {\n        json.cause = this.cause;\n      }\n      // Include all enumerable custom properties\n      const errorAsAny = this as any;\n      for (const key in errorAsAny) {\n        if (errorAsAny.hasOwnProperty(key) && !(key in json) && key !== 'toJSON') {\n          json[key] = errorAsAny[key];\n        }\n      }\n\n      return json;\n    },\n    enumerable: false,\n    writable: true,\n    configurable: true,\n  });\n}\n","import { safeParseErrorObject } from './utils.js';\nexport { getErrorFromUnknown } from './utils.js';\n\nexport enum ErrorDomain {\n  TOOL = 'TOOL',\n  AGENT = 'AGENT',\n  MCP = 'MCP',\n  AGENT_NETWORK = 'AGENT_NETWORK',\n  MASTRA_SERVER = 'MASTRA_SERVER',\n  MASTRA_TELEMETRY = 'MASTRA_TELEMETRY',\n  MASTRA_OBSERVABILITY = 'MASTRA_OBSERVABILITY',\n  MASTRA_WORKFLOW = 'MASTRA_WORKFLOW',\n  MASTRA_VOICE = 'MASTRA_VOICE',\n  MASTRA_VECTOR = 'MASTRA_VECTOR',\n  LLM = 'LLM',\n  EVAL = 'EVAL',\n  SCORER = 'SCORER',\n  A2A = 'A2A',\n  MASTRA_INSTANCE = 'MASTRA_INSTANCE',\n  MASTRA = 'MASTRA',\n  DEPLOYER = 'DEPLOYER',\n  STORAGE = 'STORAGE',\n  MODEL_ROUTER = 'MODEL_ROUTER',\n}\n\nexport enum ErrorCategory {\n  UNKNOWN = 'UNKNOWN',\n  USER = 'USER',\n  SYSTEM = 'SYSTEM',\n  THIRD_PARTY = 'THIRD_PARTY',\n}\n\ntype Scalar = null | boolean | number | string;\n\ntype Json<T> = [T] extends [Scalar | undefined]\n  ? Scalar\n  : [T] extends [{ [x: number]: unknown }]\n    ? { [K in keyof T]: Json<T[K]> }\n    : never;\n\n/**\n * Defines the structure for an error's metadata.\n * This is used to create instances of MastraError.\n */\nexport interface IErrorDefinition<D, C> {\n  /** Unique identifier for the error. */\n  id: Uppercase<string>;\n  /**\n   * Optional custom error message that overrides the original error message.\n   * If not provided, the original error message will be used, or 'Unknown error' if no error is provided.\n   */\n  text?: string;\n  /**\n   * Functional domain of the error (e.g., CONFIG, BUILD, API).\n   */\n  domain: D;\n  /** Broad category of the error (e.g., USER, SYSTEM, THIRD_PARTY). */\n  category: C;\n\n  details?: Record<string, Json<Scalar>>;\n}\n\n/**\n * Base error class for the Mastra ecosystem.\n * It standardizes error reporting and can be extended for more specific error types.\n */\nexport class MastraBaseError<D, C> extends Error {\n  public readonly id: Uppercase<string>;\n  public readonly domain: D;\n  public readonly category: C;\n  public readonly details?: Record<string, Json<Scalar>> = {};\n  public readonly message: string;\n\n  constructor(\n    errorDefinition: IErrorDefinition<D, C>,\n    originalError?: string | Error | MastraBaseError<D, C> | unknown,\n  ) {\n    // Convert originalError to Error instance\n    let error: Error | undefined;\n    if (originalError instanceof Error) {\n      error = originalError;\n    } else if (originalError) {\n      const errorMessage = safeParseErrorObject(originalError);\n      error = new Error(errorMessage);\n    }\n\n    const message = errorDefinition.text ?? error?.message ?? 'Unknown error';\n\n    super(message, { cause: error });\n    this.id = errorDefinition.id;\n    this.domain = errorDefinition.domain;\n    this.category = errorDefinition.category;\n    this.details = errorDefinition.details ?? {};\n    this.message = message;\n\n    Object.setPrototypeOf(this, new.target.prototype);\n  }\n\n  /**\n   * Returns a structured representation of the error, useful for logging or API responses.\n   */\n  public toJSONDetails() {\n    return {\n      message: this.message,\n      domain: this.domain,\n      category: this.category,\n      details: this.details,\n    };\n  }\n\n  public toJSON() {\n    return {\n      message: this.message,\n      details: this.toJSONDetails(),\n      code: this.id,\n    };\n  }\n\n  public toString() {\n    return JSON.stringify(this.toJSON());\n  }\n}\n\nexport class MastraError extends MastraBaseError<`${ErrorDomain}`, `${ErrorCategory}`> {}\n"]}