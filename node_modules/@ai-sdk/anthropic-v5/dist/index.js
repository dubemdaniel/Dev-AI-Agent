"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  VERSION: () => VERSION,
  anthropic: () => anthropic,
  createAnthropic: () => createAnthropic
});
module.exports = __toCommonJS(src_exports);

// src/anthropic-provider.ts
var import_provider4 = require("@ai-sdk/provider");
var import_provider_utils20 = require("@ai-sdk/provider-utils");

// src/version.ts
var VERSION = true ? "2.0.33" : "0.0.0-test";

// src/anthropic-messages-language-model.ts
var import_provider3 = require("@ai-sdk/provider");
var import_provider_utils11 = require("@ai-sdk/provider-utils");

// src/anthropic-error.ts
var import_provider_utils = require("@ai-sdk/provider-utils");
var import_v4 = require("zod/v4");
var anthropicErrorDataSchema = (0, import_provider_utils.lazySchema)(
  () => (0, import_provider_utils.zodSchema)(
    import_v4.z.object({
      type: import_v4.z.literal("error"),
      error: import_v4.z.object({
        type: import_v4.z.string(),
        message: import_v4.z.string()
      })
    })
  )
);
var anthropicFailedResponseHandler = (0, import_provider_utils.createJsonErrorResponseHandler)({
  errorSchema: anthropicErrorDataSchema,
  errorToMessage: (data) => data.error.message
});

// src/anthropic-messages-api.ts
var import_provider_utils2 = require("@ai-sdk/provider-utils");
var import_v42 = require("zod/v4");
var anthropicMessagesResponseSchema = (0, import_provider_utils2.lazySchema)(
  () => (0, import_provider_utils2.zodSchema)(
    import_v42.z.object({
      type: import_v42.z.literal("message"),
      id: import_v42.z.string().nullish(),
      model: import_v42.z.string().nullish(),
      content: import_v42.z.array(
        import_v42.z.discriminatedUnion("type", [
          import_v42.z.object({
            type: import_v42.z.literal("text"),
            text: import_v42.z.string(),
            citations: import_v42.z.array(
              import_v42.z.discriminatedUnion("type", [
                import_v42.z.object({
                  type: import_v42.z.literal("web_search_result_location"),
                  cited_text: import_v42.z.string(),
                  url: import_v42.z.string(),
                  title: import_v42.z.string(),
                  encrypted_index: import_v42.z.string()
                }),
                import_v42.z.object({
                  type: import_v42.z.literal("page_location"),
                  cited_text: import_v42.z.string(),
                  document_index: import_v42.z.number(),
                  document_title: import_v42.z.string().nullable(),
                  start_page_number: import_v42.z.number(),
                  end_page_number: import_v42.z.number()
                }),
                import_v42.z.object({
                  type: import_v42.z.literal("char_location"),
                  cited_text: import_v42.z.string(),
                  document_index: import_v42.z.number(),
                  document_title: import_v42.z.string().nullable(),
                  start_char_index: import_v42.z.number(),
                  end_char_index: import_v42.z.number()
                })
              ])
            ).optional()
          }),
          import_v42.z.object({
            type: import_v42.z.literal("thinking"),
            thinking: import_v42.z.string(),
            signature: import_v42.z.string()
          }),
          import_v42.z.object({
            type: import_v42.z.literal("redacted_thinking"),
            data: import_v42.z.string()
          }),
          import_v42.z.object({
            type: import_v42.z.literal("tool_use"),
            id: import_v42.z.string(),
            name: import_v42.z.string(),
            input: import_v42.z.unknown()
          }),
          import_v42.z.object({
            type: import_v42.z.literal("server_tool_use"),
            id: import_v42.z.string(),
            name: import_v42.z.string(),
            input: import_v42.z.record(import_v42.z.string(), import_v42.z.unknown()).nullish()
          }),
          import_v42.z.object({
            type: import_v42.z.literal("web_fetch_tool_result"),
            tool_use_id: import_v42.z.string(),
            content: import_v42.z.union([
              import_v42.z.object({
                type: import_v42.z.literal("web_fetch_result"),
                url: import_v42.z.string(),
                retrieved_at: import_v42.z.string(),
                content: import_v42.z.object({
                  type: import_v42.z.literal("document"),
                  title: import_v42.z.string().nullable(),
                  citations: import_v42.z.object({ enabled: import_v42.z.boolean() }).optional(),
                  source: import_v42.z.object({
                    type: import_v42.z.literal("text"),
                    media_type: import_v42.z.string(),
                    data: import_v42.z.string()
                  })
                })
              }),
              import_v42.z.object({
                type: import_v42.z.literal("web_fetch_tool_result_error"),
                error_code: import_v42.z.string()
              })
            ])
          }),
          import_v42.z.object({
            type: import_v42.z.literal("web_search_tool_result"),
            tool_use_id: import_v42.z.string(),
            content: import_v42.z.union([
              import_v42.z.array(
                import_v42.z.object({
                  type: import_v42.z.literal("web_search_result"),
                  url: import_v42.z.string(),
                  title: import_v42.z.string(),
                  encrypted_content: import_v42.z.string(),
                  page_age: import_v42.z.string().nullish()
                })
              ),
              import_v42.z.object({
                type: import_v42.z.literal("web_search_tool_result_error"),
                error_code: import_v42.z.string()
              })
            ])
          }),
          // code execution results for code_execution_20250522 tool:
          import_v42.z.object({
            type: import_v42.z.literal("code_execution_tool_result"),
            tool_use_id: import_v42.z.string(),
            content: import_v42.z.union([
              import_v42.z.object({
                type: import_v42.z.literal("code_execution_result"),
                stdout: import_v42.z.string(),
                stderr: import_v42.z.string(),
                return_code: import_v42.z.number()
              }),
              import_v42.z.object({
                type: import_v42.z.literal("code_execution_tool_result_error"),
                error_code: import_v42.z.string()
              })
            ])
          }),
          // bash code execution results for code_execution_20250825 tool:
          import_v42.z.object({
            type: import_v42.z.literal("bash_code_execution_tool_result"),
            tool_use_id: import_v42.z.string(),
            content: import_v42.z.discriminatedUnion("type", [
              import_v42.z.object({
                type: import_v42.z.literal("bash_code_execution_result"),
                content: import_v42.z.array(
                  import_v42.z.object({
                    type: import_v42.z.literal("bash_code_execution_output"),
                    file_id: import_v42.z.string()
                  })
                ),
                stdout: import_v42.z.string(),
                stderr: import_v42.z.string(),
                return_code: import_v42.z.number()
              }),
              import_v42.z.object({
                type: import_v42.z.literal("bash_code_execution_tool_result_error"),
                error_code: import_v42.z.string()
              })
            ])
          }),
          // text editor code execution results for code_execution_20250825 tool:
          import_v42.z.object({
            type: import_v42.z.literal("text_editor_code_execution_tool_result"),
            tool_use_id: import_v42.z.string(),
            content: import_v42.z.discriminatedUnion("type", [
              import_v42.z.object({
                type: import_v42.z.literal("text_editor_code_execution_tool_result_error"),
                error_code: import_v42.z.string()
              }),
              import_v42.z.object({
                type: import_v42.z.literal("text_editor_code_execution_view_result"),
                content: import_v42.z.string(),
                file_type: import_v42.z.string(),
                num_lines: import_v42.z.number().nullable(),
                start_line: import_v42.z.number().nullable(),
                total_lines: import_v42.z.number().nullable()
              }),
              import_v42.z.object({
                type: import_v42.z.literal("text_editor_code_execution_create_result"),
                is_file_update: import_v42.z.boolean()
              }),
              import_v42.z.object({
                type: import_v42.z.literal(
                  "text_editor_code_execution_str_replace_result"
                ),
                lines: import_v42.z.array(import_v42.z.string()).nullable(),
                new_lines: import_v42.z.number().nullable(),
                new_start: import_v42.z.number().nullable(),
                old_lines: import_v42.z.number().nullable(),
                old_start: import_v42.z.number().nullable()
              })
            ])
          })
        ])
      ),
      stop_reason: import_v42.z.string().nullish(),
      stop_sequence: import_v42.z.string().nullish(),
      usage: import_v42.z.looseObject({
        input_tokens: import_v42.z.number(),
        output_tokens: import_v42.z.number(),
        cache_creation_input_tokens: import_v42.z.number().nullish(),
        cache_read_input_tokens: import_v42.z.number().nullish()
      })
    })
  )
);
var anthropicMessagesChunkSchema = (0, import_provider_utils2.lazySchema)(
  () => (0, import_provider_utils2.zodSchema)(
    import_v42.z.discriminatedUnion("type", [
      import_v42.z.object({
        type: import_v42.z.literal("message_start"),
        message: import_v42.z.object({
          id: import_v42.z.string().nullish(),
          model: import_v42.z.string().nullish(),
          usage: import_v42.z.looseObject({
            input_tokens: import_v42.z.number(),
            cache_creation_input_tokens: import_v42.z.number().nullish(),
            cache_read_input_tokens: import_v42.z.number().nullish()
          })
        })
      }),
      import_v42.z.object({
        type: import_v42.z.literal("content_block_start"),
        index: import_v42.z.number(),
        content_block: import_v42.z.discriminatedUnion("type", [
          import_v42.z.object({
            type: import_v42.z.literal("text"),
            text: import_v42.z.string()
          }),
          import_v42.z.object({
            type: import_v42.z.literal("thinking"),
            thinking: import_v42.z.string()
          }),
          import_v42.z.object({
            type: import_v42.z.literal("tool_use"),
            id: import_v42.z.string(),
            name: import_v42.z.string()
          }),
          import_v42.z.object({
            type: import_v42.z.literal("redacted_thinking"),
            data: import_v42.z.string()
          }),
          import_v42.z.object({
            type: import_v42.z.literal("server_tool_use"),
            id: import_v42.z.string(),
            name: import_v42.z.string(),
            input: import_v42.z.record(import_v42.z.string(), import_v42.z.unknown()).nullish()
          }),
          import_v42.z.object({
            type: import_v42.z.literal("web_fetch_tool_result"),
            tool_use_id: import_v42.z.string(),
            content: import_v42.z.union([
              import_v42.z.object({
                type: import_v42.z.literal("web_fetch_result"),
                url: import_v42.z.string(),
                retrieved_at: import_v42.z.string(),
                content: import_v42.z.object({
                  type: import_v42.z.literal("document"),
                  title: import_v42.z.string().nullable(),
                  citations: import_v42.z.object({ enabled: import_v42.z.boolean() }).optional(),
                  source: import_v42.z.object({
                    type: import_v42.z.literal("text"),
                    media_type: import_v42.z.string(),
                    data: import_v42.z.string()
                  })
                })
              }),
              import_v42.z.object({
                type: import_v42.z.literal("web_fetch_tool_result_error"),
                error_code: import_v42.z.string()
              })
            ])
          }),
          import_v42.z.object({
            type: import_v42.z.literal("web_search_tool_result"),
            tool_use_id: import_v42.z.string(),
            content: import_v42.z.union([
              import_v42.z.array(
                import_v42.z.object({
                  type: import_v42.z.literal("web_search_result"),
                  url: import_v42.z.string(),
                  title: import_v42.z.string(),
                  encrypted_content: import_v42.z.string(),
                  page_age: import_v42.z.string().nullish()
                })
              ),
              import_v42.z.object({
                type: import_v42.z.literal("web_search_tool_result_error"),
                error_code: import_v42.z.string()
              })
            ])
          }),
          // code execution results for code_execution_20250522 tool:
          import_v42.z.object({
            type: import_v42.z.literal("code_execution_tool_result"),
            tool_use_id: import_v42.z.string(),
            content: import_v42.z.union([
              import_v42.z.object({
                type: import_v42.z.literal("code_execution_result"),
                stdout: import_v42.z.string(),
                stderr: import_v42.z.string(),
                return_code: import_v42.z.number()
              }),
              import_v42.z.object({
                type: import_v42.z.literal("code_execution_tool_result_error"),
                error_code: import_v42.z.string()
              })
            ])
          }),
          // bash code execution results for code_execution_20250825 tool:
          import_v42.z.object({
            type: import_v42.z.literal("bash_code_execution_tool_result"),
            tool_use_id: import_v42.z.string(),
            content: import_v42.z.discriminatedUnion("type", [
              import_v42.z.object({
                type: import_v42.z.literal("bash_code_execution_result"),
                content: import_v42.z.array(
                  import_v42.z.object({
                    type: import_v42.z.literal("bash_code_execution_output"),
                    file_id: import_v42.z.string()
                  })
                ),
                stdout: import_v42.z.string(),
                stderr: import_v42.z.string(),
                return_code: import_v42.z.number()
              }),
              import_v42.z.object({
                type: import_v42.z.literal("bash_code_execution_tool_result_error"),
                error_code: import_v42.z.string()
              })
            ])
          }),
          // text editor code execution results for code_execution_20250825 tool:
          import_v42.z.object({
            type: import_v42.z.literal("text_editor_code_execution_tool_result"),
            tool_use_id: import_v42.z.string(),
            content: import_v42.z.discriminatedUnion("type", [
              import_v42.z.object({
                type: import_v42.z.literal("text_editor_code_execution_tool_result_error"),
                error_code: import_v42.z.string()
              }),
              import_v42.z.object({
                type: import_v42.z.literal("text_editor_code_execution_view_result"),
                content: import_v42.z.string(),
                file_type: import_v42.z.string(),
                num_lines: import_v42.z.number().nullable(),
                start_line: import_v42.z.number().nullable(),
                total_lines: import_v42.z.number().nullable()
              }),
              import_v42.z.object({
                type: import_v42.z.literal("text_editor_code_execution_create_result"),
                is_file_update: import_v42.z.boolean()
              }),
              import_v42.z.object({
                type: import_v42.z.literal(
                  "text_editor_code_execution_str_replace_result"
                ),
                lines: import_v42.z.array(import_v42.z.string()).nullable(),
                new_lines: import_v42.z.number().nullable(),
                new_start: import_v42.z.number().nullable(),
                old_lines: import_v42.z.number().nullable(),
                old_start: import_v42.z.number().nullable()
              })
            ])
          })
        ])
      }),
      import_v42.z.object({
        type: import_v42.z.literal("content_block_delta"),
        index: import_v42.z.number(),
        delta: import_v42.z.discriminatedUnion("type", [
          import_v42.z.object({
            type: import_v42.z.literal("input_json_delta"),
            partial_json: import_v42.z.string()
          }),
          import_v42.z.object({
            type: import_v42.z.literal("text_delta"),
            text: import_v42.z.string()
          }),
          import_v42.z.object({
            type: import_v42.z.literal("thinking_delta"),
            thinking: import_v42.z.string()
          }),
          import_v42.z.object({
            type: import_v42.z.literal("signature_delta"),
            signature: import_v42.z.string()
          }),
          import_v42.z.object({
            type: import_v42.z.literal("citations_delta"),
            citation: import_v42.z.discriminatedUnion("type", [
              import_v42.z.object({
                type: import_v42.z.literal("web_search_result_location"),
                cited_text: import_v42.z.string(),
                url: import_v42.z.string(),
                title: import_v42.z.string(),
                encrypted_index: import_v42.z.string()
              }),
              import_v42.z.object({
                type: import_v42.z.literal("page_location"),
                cited_text: import_v42.z.string(),
                document_index: import_v42.z.number(),
                document_title: import_v42.z.string().nullable(),
                start_page_number: import_v42.z.number(),
                end_page_number: import_v42.z.number()
              }),
              import_v42.z.object({
                type: import_v42.z.literal("char_location"),
                cited_text: import_v42.z.string(),
                document_index: import_v42.z.number(),
                document_title: import_v42.z.string().nullable(),
                start_char_index: import_v42.z.number(),
                end_char_index: import_v42.z.number()
              })
            ])
          })
        ])
      }),
      import_v42.z.object({
        type: import_v42.z.literal("content_block_stop"),
        index: import_v42.z.number()
      }),
      import_v42.z.object({
        type: import_v42.z.literal("error"),
        error: import_v42.z.object({
          type: import_v42.z.string(),
          message: import_v42.z.string()
        })
      }),
      import_v42.z.object({
        type: import_v42.z.literal("message_delta"),
        delta: import_v42.z.object({
          stop_reason: import_v42.z.string().nullish(),
          stop_sequence: import_v42.z.string().nullish()
        }),
        usage: import_v42.z.looseObject({
          output_tokens: import_v42.z.number(),
          cache_creation_input_tokens: import_v42.z.number().nullish()
        })
      }),
      import_v42.z.object({
        type: import_v42.z.literal("message_stop")
      }),
      import_v42.z.object({
        type: import_v42.z.literal("ping")
      })
    ])
  )
);
var anthropicReasoningMetadataSchema = (0, import_provider_utils2.lazySchema)(
  () => (0, import_provider_utils2.zodSchema)(
    import_v42.z.object({
      signature: import_v42.z.string().optional(),
      redactedData: import_v42.z.string().optional()
    })
  )
);

// src/anthropic-messages-options.ts
var import_v43 = require("zod/v4");
var anthropicFilePartProviderOptions = import_v43.z.object({
  /**
   * Citation configuration for this document.
   * When enabled, this document will generate citations in the response.
   */
  citations: import_v43.z.object({
    /**
     * Enable citations for this document
     */
    enabled: import_v43.z.boolean()
  }).optional(),
  /**
   * Custom title for the document.
   * If not provided, the filename will be used.
   */
  title: import_v43.z.string().optional(),
  /**
   * Context about the document that will be passed to the model
   * but not used towards cited content.
   * Useful for storing document metadata as text or stringified JSON.
   */
  context: import_v43.z.string().optional()
});
var anthropicProviderOptions = import_v43.z.object({
  sendReasoning: import_v43.z.boolean().optional(),
  thinking: import_v43.z.object({
    type: import_v43.z.union([import_v43.z.literal("enabled"), import_v43.z.literal("disabled")]),
    budgetTokens: import_v43.z.number().optional()
  }).optional(),
  /**
   * Whether to disable parallel function calling during tool use. Default is false.
   * When set to true, Claude will use at most one tool per response.
   */
  disableParallelToolUse: import_v43.z.boolean().optional(),
  /**
   * Cache control settings for this message.
   * See https://docs.anthropic.com/en/docs/build-with-claude/prompt-caching
   */
  cacheControl: import_v43.z.object({
    type: import_v43.z.literal("ephemeral"),
    ttl: import_v43.z.union([import_v43.z.literal("5m"), import_v43.z.literal("1h")]).optional()
  }).optional(),
  /**
   * Agent Skills configuration. Skills enable Claude to perform specialized tasks
   * like document processing (PPTX, DOCX, PDF, XLSX) and data analysis.
   * Requires code execution tool to be enabled.
   */
  container: import_v43.z.object({
    id: import_v43.z.string().optional(),
    skills: import_v43.z.array(
      import_v43.z.object({
        type: import_v43.z.union([import_v43.z.literal("anthropic"), import_v43.z.literal("custom")]),
        skillId: import_v43.z.string(),
        version: import_v43.z.string().optional()
      })
    ).optional()
  }).optional()
});

// src/anthropic-prepare-tools.ts
var import_provider = require("@ai-sdk/provider");

// src/get-cache-control.ts
var MAX_CACHE_BREAKPOINTS = 4;
function getCacheControl(providerMetadata) {
  var _a;
  const anthropic2 = providerMetadata == null ? void 0 : providerMetadata.anthropic;
  const cacheControlValue = (_a = anthropic2 == null ? void 0 : anthropic2.cacheControl) != null ? _a : anthropic2 == null ? void 0 : anthropic2.cache_control;
  return cacheControlValue;
}
var CacheControlValidator = class {
  constructor() {
    this.breakpointCount = 0;
    this.warnings = [];
  }
  getCacheControl(providerMetadata, context) {
    const cacheControlValue = getCacheControl(providerMetadata);
    if (!cacheControlValue) {
      return void 0;
    }
    if (!context.canCache) {
      this.warnings.push({
        type: "unsupported-setting",
        setting: "cacheControl",
        details: `cache_control cannot be set on ${context.type}. It will be ignored.`
      });
      return void 0;
    }
    this.breakpointCount++;
    if (this.breakpointCount > MAX_CACHE_BREAKPOINTS) {
      this.warnings.push({
        type: "unsupported-setting",
        setting: "cacheControl",
        details: `Maximum ${MAX_CACHE_BREAKPOINTS} cache breakpoints exceeded (found ${this.breakpointCount}). This breakpoint will be ignored.`
      });
      return void 0;
    }
    return cacheControlValue;
  }
  getWarnings() {
    return this.warnings;
  }
};

// src/tool/text-editor_20250728.ts
var import_provider_utils3 = require("@ai-sdk/provider-utils");
var import_v44 = require("zod/v4");
var import_provider_utils4 = require("@ai-sdk/provider-utils");
var textEditor_20250728ArgsSchema = (0, import_provider_utils4.lazySchema)(
  () => (0, import_provider_utils4.zodSchema)(
    import_v44.z.object({
      maxCharacters: import_v44.z.number().optional()
    })
  )
);
var textEditor_20250728InputSchema = (0, import_provider_utils4.lazySchema)(
  () => (0, import_provider_utils4.zodSchema)(
    import_v44.z.object({
      command: import_v44.z.enum(["view", "create", "str_replace", "insert"]),
      path: import_v44.z.string(),
      file_text: import_v44.z.string().optional(),
      insert_line: import_v44.z.number().int().optional(),
      new_str: import_v44.z.string().optional(),
      old_str: import_v44.z.string().optional(),
      view_range: import_v44.z.array(import_v44.z.number().int()).optional()
    })
  )
);
var factory = (0, import_provider_utils3.createProviderDefinedToolFactory)({
  id: "anthropic.text_editor_20250728",
  name: "str_replace_based_edit_tool",
  inputSchema: textEditor_20250728InputSchema
});
var textEditor_20250728 = (args = {}) => {
  return factory(args);
};

// src/tool/web-search_20250305.ts
var import_provider_utils5 = require("@ai-sdk/provider-utils");
var import_v45 = require("zod/v4");
var webSearch_20250305ArgsSchema = (0, import_provider_utils5.lazySchema)(
  () => (0, import_provider_utils5.zodSchema)(
    import_v45.z.object({
      maxUses: import_v45.z.number().optional(),
      allowedDomains: import_v45.z.array(import_v45.z.string()).optional(),
      blockedDomains: import_v45.z.array(import_v45.z.string()).optional(),
      userLocation: import_v45.z.object({
        type: import_v45.z.literal("approximate"),
        city: import_v45.z.string().optional(),
        region: import_v45.z.string().optional(),
        country: import_v45.z.string().optional(),
        timezone: import_v45.z.string().optional()
      }).optional()
    })
  )
);
var webSearch_20250305OutputSchema = (0, import_provider_utils5.lazySchema)(
  () => (0, import_provider_utils5.zodSchema)(
    import_v45.z.array(
      import_v45.z.object({
        url: import_v45.z.string(),
        title: import_v45.z.string(),
        pageAge: import_v45.z.string().nullable(),
        encryptedContent: import_v45.z.string(),
        type: import_v45.z.literal("web_search_result")
      })
    )
  )
);
var webSearch_20250305InputSchema = (0, import_provider_utils5.lazySchema)(
  () => (0, import_provider_utils5.zodSchema)(
    import_v45.z.object({
      query: import_v45.z.string()
    })
  )
);
var factory2 = (0, import_provider_utils5.createProviderDefinedToolFactoryWithOutputSchema)({
  id: "anthropic.web_search_20250305",
  name: "web_search",
  inputSchema: webSearch_20250305InputSchema,
  outputSchema: webSearch_20250305OutputSchema
});
var webSearch_20250305 = (args = {}) => {
  return factory2(args);
};

// src/tool/web-fetch-20250910.ts
var import_provider_utils6 = require("@ai-sdk/provider-utils");
var import_v46 = require("zod/v4");
var webFetch_20250910ArgsSchema = (0, import_provider_utils6.lazySchema)(
  () => (0, import_provider_utils6.zodSchema)(
    import_v46.z.object({
      maxUses: import_v46.z.number().optional(),
      allowedDomains: import_v46.z.array(import_v46.z.string()).optional(),
      blockedDomains: import_v46.z.array(import_v46.z.string()).optional(),
      citations: import_v46.z.object({ enabled: import_v46.z.boolean() }).optional(),
      maxContentTokens: import_v46.z.number().optional()
    })
  )
);
var webFetch_20250910OutputSchema = (0, import_provider_utils6.lazySchema)(
  () => (0, import_provider_utils6.zodSchema)(
    import_v46.z.object({
      type: import_v46.z.literal("web_fetch_result"),
      url: import_v46.z.string(),
      content: import_v46.z.object({
        type: import_v46.z.literal("document"),
        title: import_v46.z.string(),
        citations: import_v46.z.object({ enabled: import_v46.z.boolean() }).optional(),
        source: import_v46.z.union([
          import_v46.z.object({
            type: import_v46.z.literal("base64"),
            mediaType: import_v46.z.literal("application/pdf"),
            data: import_v46.z.string()
          }),
          import_v46.z.object({
            type: import_v46.z.literal("text"),
            mediaType: import_v46.z.literal("text/plain"),
            data: import_v46.z.string()
          })
        ])
      }),
      retrievedAt: import_v46.z.string().nullable()
    })
  )
);
var webFetch_20250910InputSchema = (0, import_provider_utils6.lazySchema)(
  () => (0, import_provider_utils6.zodSchema)(
    import_v46.z.object({
      url: import_v46.z.string()
    })
  )
);
var factory3 = (0, import_provider_utils6.createProviderDefinedToolFactoryWithOutputSchema)({
  id: "anthropic.web_fetch_20250910",
  name: "web_fetch",
  inputSchema: webFetch_20250910InputSchema,
  outputSchema: webFetch_20250910OutputSchema
});
var webFetch_20250910 = (args = {}) => {
  return factory3(args);
};

// src/anthropic-prepare-tools.ts
var import_provider_utils7 = require("@ai-sdk/provider-utils");
async function prepareTools({
  tools,
  toolChoice,
  disableParallelToolUse,
  cacheControlValidator
}) {
  tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
  const toolWarnings = [];
  const betas = /* @__PURE__ */ new Set();
  const validator = cacheControlValidator || new CacheControlValidator();
  if (tools == null) {
    return { tools: void 0, toolChoice: void 0, toolWarnings, betas };
  }
  const anthropicTools2 = [];
  for (const tool of tools) {
    switch (tool.type) {
      case "function": {
        const cacheControl = validator.getCacheControl(tool.providerOptions, {
          type: "tool definition",
          canCache: true
        });
        anthropicTools2.push({
          name: tool.name,
          description: tool.description,
          input_schema: tool.inputSchema,
          cache_control: cacheControl
        });
        break;
      }
      case "provider-defined": {
        switch (tool.id) {
          case "anthropic.code_execution_20250522": {
            betas.add("code-execution-2025-05-22");
            anthropicTools2.push({
              type: "code_execution_20250522",
              name: "code_execution",
              cache_control: void 0
            });
            break;
          }
          case "anthropic.code_execution_20250825": {
            betas.add("code-execution-2025-08-25");
            anthropicTools2.push({
              type: "code_execution_20250825",
              name: "code_execution"
            });
            break;
          }
          case "anthropic.computer_20250124": {
            betas.add("computer-use-2025-01-24");
            anthropicTools2.push({
              name: "computer",
              type: "computer_20250124",
              display_width_px: tool.args.displayWidthPx,
              display_height_px: tool.args.displayHeightPx,
              display_number: tool.args.displayNumber,
              cache_control: void 0
            });
            break;
          }
          case "anthropic.computer_20241022": {
            betas.add("computer-use-2024-10-22");
            anthropicTools2.push({
              name: "computer",
              type: "computer_20241022",
              display_width_px: tool.args.displayWidthPx,
              display_height_px: tool.args.displayHeightPx,
              display_number: tool.args.displayNumber,
              cache_control: void 0
            });
            break;
          }
          case "anthropic.text_editor_20250124": {
            betas.add("computer-use-2025-01-24");
            anthropicTools2.push({
              name: "str_replace_editor",
              type: "text_editor_20250124",
              cache_control: void 0
            });
            break;
          }
          case "anthropic.text_editor_20241022": {
            betas.add("computer-use-2024-10-22");
            anthropicTools2.push({
              name: "str_replace_editor",
              type: "text_editor_20241022",
              cache_control: void 0
            });
            break;
          }
          case "anthropic.text_editor_20250429": {
            betas.add("computer-use-2025-01-24");
            anthropicTools2.push({
              name: "str_replace_based_edit_tool",
              type: "text_editor_20250429",
              cache_control: void 0
            });
            break;
          }
          case "anthropic.text_editor_20250728": {
            const args = await (0, import_provider_utils7.validateTypes)({
              value: tool.args,
              schema: textEditor_20250728ArgsSchema
            });
            anthropicTools2.push({
              name: "str_replace_based_edit_tool",
              type: "text_editor_20250728",
              max_characters: args.maxCharacters,
              cache_control: void 0
            });
            break;
          }
          case "anthropic.bash_20250124": {
            betas.add("computer-use-2025-01-24");
            anthropicTools2.push({
              name: "bash",
              type: "bash_20250124",
              cache_control: void 0
            });
            break;
          }
          case "anthropic.bash_20241022": {
            betas.add("computer-use-2024-10-22");
            anthropicTools2.push({
              name: "bash",
              type: "bash_20241022",
              cache_control: void 0
            });
            break;
          }
          case "anthropic.memory_20250818": {
            betas.add("context-management-2025-06-27");
            anthropicTools2.push({
              name: "memory",
              type: "memory_20250818"
            });
            break;
          }
          case "anthropic.web_fetch_20250910": {
            betas.add("web-fetch-2025-09-10");
            const args = await (0, import_provider_utils7.validateTypes)({
              value: tool.args,
              schema: webFetch_20250910ArgsSchema
            });
            anthropicTools2.push({
              type: "web_fetch_20250910",
              name: "web_fetch",
              max_uses: args.maxUses,
              allowed_domains: args.allowedDomains,
              blocked_domains: args.blockedDomains,
              citations: args.citations,
              max_content_tokens: args.maxContentTokens,
              cache_control: void 0
            });
            break;
          }
          case "anthropic.web_search_20250305": {
            const args = await (0, import_provider_utils7.validateTypes)({
              value: tool.args,
              schema: webSearch_20250305ArgsSchema
            });
            anthropicTools2.push({
              type: "web_search_20250305",
              name: "web_search",
              max_uses: args.maxUses,
              allowed_domains: args.allowedDomains,
              blocked_domains: args.blockedDomains,
              user_location: args.userLocation,
              cache_control: void 0
            });
            break;
          }
          default: {
            toolWarnings.push({ type: "unsupported-tool", tool });
            break;
          }
        }
        break;
      }
      default: {
        toolWarnings.push({ type: "unsupported-tool", tool });
        break;
      }
    }
  }
  if (toolChoice == null) {
    return {
      tools: anthropicTools2,
      toolChoice: disableParallelToolUse ? { type: "auto", disable_parallel_tool_use: disableParallelToolUse } : void 0,
      toolWarnings,
      betas
    };
  }
  const type = toolChoice.type;
  switch (type) {
    case "auto":
      return {
        tools: anthropicTools2,
        toolChoice: {
          type: "auto",
          disable_parallel_tool_use: disableParallelToolUse
        },
        toolWarnings,
        betas
      };
    case "required":
      return {
        tools: anthropicTools2,
        toolChoice: {
          type: "any",
          disable_parallel_tool_use: disableParallelToolUse
        },
        toolWarnings,
        betas
      };
    case "none":
      return { tools: void 0, toolChoice: void 0, toolWarnings, betas };
    case "tool":
      return {
        tools: anthropicTools2,
        toolChoice: {
          type: "tool",
          name: toolChoice.toolName,
          disable_parallel_tool_use: disableParallelToolUse
        },
        toolWarnings,
        betas
      };
    default: {
      const _exhaustiveCheck = type;
      throw new import_provider.UnsupportedFunctionalityError({
        functionality: `tool choice type: ${_exhaustiveCheck}`
      });
    }
  }
}

// src/convert-to-anthropic-messages-prompt.ts
var import_provider2 = require("@ai-sdk/provider");
var import_provider_utils10 = require("@ai-sdk/provider-utils");

// src/tool/code-execution_20250522.ts
var import_provider_utils8 = require("@ai-sdk/provider-utils");
var import_v47 = require("zod/v4");
var codeExecution_20250522OutputSchema = (0, import_provider_utils8.lazySchema)(
  () => (0, import_provider_utils8.zodSchema)(
    import_v47.z.object({
      type: import_v47.z.literal("code_execution_result"),
      stdout: import_v47.z.string(),
      stderr: import_v47.z.string(),
      return_code: import_v47.z.number()
    })
  )
);
var codeExecution_20250522InputSchema = (0, import_provider_utils8.lazySchema)(
  () => (0, import_provider_utils8.zodSchema)(
    import_v47.z.object({
      code: import_v47.z.string()
    })
  )
);
var factory4 = (0, import_provider_utils8.createProviderDefinedToolFactoryWithOutputSchema)({
  id: "anthropic.code_execution_20250522",
  name: "code_execution",
  inputSchema: codeExecution_20250522InputSchema,
  outputSchema: codeExecution_20250522OutputSchema
});
var codeExecution_20250522 = (args = {}) => {
  return factory4(args);
};

// src/tool/code-execution_20250825.ts
var import_provider_utils9 = require("@ai-sdk/provider-utils");
var import_v48 = require("zod/v4");
var codeExecution_20250825OutputSchema = (0, import_provider_utils9.lazySchema)(
  () => (0, import_provider_utils9.zodSchema)(
    import_v48.z.discriminatedUnion("type", [
      import_v48.z.object({
        type: import_v48.z.literal("bash_code_execution_result"),
        content: import_v48.z.array(
          import_v48.z.object({
            type: import_v48.z.literal("bash_code_execution_output"),
            file_id: import_v48.z.string()
          })
        ),
        stdout: import_v48.z.string(),
        stderr: import_v48.z.string(),
        return_code: import_v48.z.number()
      }),
      import_v48.z.object({
        type: import_v48.z.literal("bash_code_execution_tool_result_error"),
        error_code: import_v48.z.string()
      }),
      import_v48.z.object({
        type: import_v48.z.literal("text_editor_code_execution_tool_result_error"),
        error_code: import_v48.z.string()
      }),
      import_v48.z.object({
        type: import_v48.z.literal("text_editor_code_execution_view_result"),
        content: import_v48.z.string(),
        file_type: import_v48.z.string(),
        num_lines: import_v48.z.number().nullable(),
        start_line: import_v48.z.number().nullable(),
        total_lines: import_v48.z.number().nullable()
      }),
      import_v48.z.object({
        type: import_v48.z.literal("text_editor_code_execution_create_result"),
        is_file_update: import_v48.z.boolean()
      }),
      import_v48.z.object({
        type: import_v48.z.literal("text_editor_code_execution_str_replace_result"),
        lines: import_v48.z.array(import_v48.z.string()).nullable(),
        new_lines: import_v48.z.number().nullable(),
        new_start: import_v48.z.number().nullable(),
        old_lines: import_v48.z.number().nullable(),
        old_start: import_v48.z.number().nullable()
      })
    ])
  )
);
var codeExecution_20250825InputSchema = (0, import_provider_utils9.lazySchema)(
  () => (0, import_provider_utils9.zodSchema)(
    import_v48.z.discriminatedUnion("type", [
      import_v48.z.object({
        type: import_v48.z.literal("bash_code_execution"),
        command: import_v48.z.string()
      }),
      import_v48.z.discriminatedUnion("command", [
        import_v48.z.object({
          type: import_v48.z.literal("text_editor_code_execution"),
          command: import_v48.z.literal("view"),
          path: import_v48.z.string()
        }),
        import_v48.z.object({
          type: import_v48.z.literal("text_editor_code_execution"),
          command: import_v48.z.literal("create"),
          path: import_v48.z.string(),
          file_text: import_v48.z.string().nullish()
        }),
        import_v48.z.object({
          type: import_v48.z.literal("text_editor_code_execution"),
          command: import_v48.z.literal("str_replace"),
          path: import_v48.z.string(),
          old_str: import_v48.z.string(),
          new_str: import_v48.z.string()
        })
      ])
    ])
  )
);
var factory5 = (0, import_provider_utils9.createProviderDefinedToolFactoryWithOutputSchema)({
  id: "anthropic.code_execution_20250825",
  name: "code_execution",
  inputSchema: codeExecution_20250825InputSchema,
  outputSchema: codeExecution_20250825OutputSchema
});
var codeExecution_20250825 = (args = {}) => {
  return factory5(args);
};

// src/convert-to-anthropic-messages-prompt.ts
function convertToString(data) {
  if (typeof data === "string") {
    return Buffer.from(data, "base64").toString("utf-8");
  }
  if (data instanceof Uint8Array) {
    return new TextDecoder().decode(data);
  }
  if (data instanceof URL) {
    throw new import_provider2.UnsupportedFunctionalityError({
      functionality: "URL-based text documents are not supported for citations"
    });
  }
  throw new import_provider2.UnsupportedFunctionalityError({
    functionality: `unsupported data type for text documents: ${typeof data}`
  });
}
async function convertToAnthropicMessagesPrompt({
  prompt,
  sendReasoning,
  warnings,
  cacheControlValidator
}) {
  var _a, _b, _c, _d, _e;
  const betas = /* @__PURE__ */ new Set();
  const blocks = groupIntoBlocks(prompt);
  const validator = cacheControlValidator || new CacheControlValidator();
  let system = void 0;
  const messages = [];
  async function shouldEnableCitations(providerMetadata) {
    var _a2, _b2;
    const anthropicOptions = await (0, import_provider_utils10.parseProviderOptions)({
      provider: "anthropic",
      providerOptions: providerMetadata,
      schema: anthropicFilePartProviderOptions
    });
    return (_b2 = (_a2 = anthropicOptions == null ? void 0 : anthropicOptions.citations) == null ? void 0 : _a2.enabled) != null ? _b2 : false;
  }
  async function getDocumentMetadata(providerMetadata) {
    const anthropicOptions = await (0, import_provider_utils10.parseProviderOptions)({
      provider: "anthropic",
      providerOptions: providerMetadata,
      schema: anthropicFilePartProviderOptions
    });
    return {
      title: anthropicOptions == null ? void 0 : anthropicOptions.title,
      context: anthropicOptions == null ? void 0 : anthropicOptions.context
    };
  }
  for (let i = 0; i < blocks.length; i++) {
    const block = blocks[i];
    const isLastBlock = i === blocks.length - 1;
    const type = block.type;
    switch (type) {
      case "system": {
        if (system != null) {
          throw new import_provider2.UnsupportedFunctionalityError({
            functionality: "Multiple system messages that are separated by user/assistant messages"
          });
        }
        system = block.messages.map(({ content, providerOptions }) => ({
          type: "text",
          text: content,
          cache_control: validator.getCacheControl(providerOptions, {
            type: "system message",
            canCache: true
          })
        }));
        break;
      }
      case "user": {
        const anthropicContent = [];
        for (const message of block.messages) {
          const { role, content } = message;
          switch (role) {
            case "user": {
              for (let j = 0; j < content.length; j++) {
                const part = content[j];
                const isLastPart = j === content.length - 1;
                const cacheControl = (_a = validator.getCacheControl(part.providerOptions, {
                  type: "user message part",
                  canCache: true
                })) != null ? _a : isLastPart ? validator.getCacheControl(message.providerOptions, {
                  type: "user message",
                  canCache: true
                }) : void 0;
                switch (part.type) {
                  case "text": {
                    anthropicContent.push({
                      type: "text",
                      text: part.text,
                      cache_control: cacheControl
                    });
                    break;
                  }
                  case "file": {
                    if (part.mediaType.startsWith("image/")) {
                      anthropicContent.push({
                        type: "image",
                        source: part.data instanceof URL ? {
                          type: "url",
                          url: part.data.toString()
                        } : {
                          type: "base64",
                          media_type: part.mediaType === "image/*" ? "image/jpeg" : part.mediaType,
                          data: (0, import_provider_utils10.convertToBase64)(part.data)
                        },
                        cache_control: cacheControl
                      });
                    } else if (part.mediaType === "application/pdf") {
                      betas.add("pdfs-2024-09-25");
                      const enableCitations = await shouldEnableCitations(
                        part.providerOptions
                      );
                      const metadata = await getDocumentMetadata(
                        part.providerOptions
                      );
                      anthropicContent.push({
                        type: "document",
                        source: part.data instanceof URL ? {
                          type: "url",
                          url: part.data.toString()
                        } : {
                          type: "base64",
                          media_type: "application/pdf",
                          data: (0, import_provider_utils10.convertToBase64)(part.data)
                        },
                        title: (_b = metadata.title) != null ? _b : part.filename,
                        ...metadata.context && { context: metadata.context },
                        ...enableCitations && {
                          citations: { enabled: true }
                        },
                        cache_control: cacheControl
                      });
                    } else if (part.mediaType === "text/plain") {
                      const enableCitations = await shouldEnableCitations(
                        part.providerOptions
                      );
                      const metadata = await getDocumentMetadata(
                        part.providerOptions
                      );
                      anthropicContent.push({
                        type: "document",
                        source: part.data instanceof URL ? {
                          type: "url",
                          url: part.data.toString()
                        } : {
                          type: "text",
                          media_type: "text/plain",
                          data: convertToString(part.data)
                        },
                        title: (_c = metadata.title) != null ? _c : part.filename,
                        ...metadata.context && { context: metadata.context },
                        ...enableCitations && {
                          citations: { enabled: true }
                        },
                        cache_control: cacheControl
                      });
                    } else {
                      throw new import_provider2.UnsupportedFunctionalityError({
                        functionality: `media type: ${part.mediaType}`
                      });
                    }
                    break;
                  }
                }
              }
              break;
            }
            case "tool": {
              for (let i2 = 0; i2 < content.length; i2++) {
                const part = content[i2];
                const isLastPart = i2 === content.length - 1;
                const cacheControl = (_d = validator.getCacheControl(part.providerOptions, {
                  type: "tool result part",
                  canCache: true
                })) != null ? _d : isLastPart ? validator.getCacheControl(message.providerOptions, {
                  type: "tool result message",
                  canCache: true
                }) : void 0;
                const output = part.output;
                let contentValue;
                switch (output.type) {
                  case "content":
                    contentValue = output.value.map((contentPart) => {
                      switch (contentPart.type) {
                        case "text":
                          return {
                            type: "text",
                            text: contentPart.text
                          };
                        case "media": {
                          if (contentPart.mediaType.startsWith("image/")) {
                            return {
                              type: "image",
                              source: {
                                type: "base64",
                                media_type: contentPart.mediaType,
                                data: contentPart.data
                              }
                            };
                          }
                          if (contentPart.mediaType === "application/pdf") {
                            betas.add("pdfs-2024-09-25");
                            return {
                              type: "document",
                              source: {
                                type: "base64",
                                media_type: contentPart.mediaType,
                                data: contentPart.data
                              }
                            };
                          }
                          throw new import_provider2.UnsupportedFunctionalityError({
                            functionality: `media type: ${contentPart.mediaType}`
                          });
                        }
                      }
                    });
                    break;
                  case "text":
                  case "error-text":
                    contentValue = output.value;
                    break;
                  case "json":
                  case "error-json":
                  default:
                    contentValue = JSON.stringify(output.value);
                    break;
                }
                anthropicContent.push({
                  type: "tool_result",
                  tool_use_id: part.toolCallId,
                  content: contentValue,
                  is_error: output.type === "error-text" || output.type === "error-json" ? true : void 0,
                  cache_control: cacheControl
                });
              }
              break;
            }
            default: {
              const _exhaustiveCheck = role;
              throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
            }
          }
        }
        messages.push({ role: "user", content: anthropicContent });
        break;
      }
      case "assistant": {
        const anthropicContent = [];
        for (let j = 0; j < block.messages.length; j++) {
          const message = block.messages[j];
          const isLastMessage = j === block.messages.length - 1;
          const { content } = message;
          for (let k = 0; k < content.length; k++) {
            const part = content[k];
            const isLastContentPart = k === content.length - 1;
            const cacheControl = (_e = validator.getCacheControl(part.providerOptions, {
              type: "assistant message part",
              canCache: true
            })) != null ? _e : isLastContentPart ? validator.getCacheControl(message.providerOptions, {
              type: "assistant message",
              canCache: true
            }) : void 0;
            switch (part.type) {
              case "text": {
                anthropicContent.push({
                  type: "text",
                  text: (
                    // trim the last text part if it's the last message in the block
                    // because Anthropic does not allow trailing whitespace
                    // in pre-filled assistant responses
                    isLastBlock && isLastMessage && isLastContentPart ? part.text.trim() : part.text
                  ),
                  cache_control: cacheControl
                });
                break;
              }
              case "reasoning": {
                if (sendReasoning) {
                  const reasoningMetadata = await (0, import_provider_utils10.parseProviderOptions)({
                    provider: "anthropic",
                    providerOptions: part.providerOptions,
                    schema: anthropicReasoningMetadataSchema
                  });
                  if (reasoningMetadata != null) {
                    if (reasoningMetadata.signature != null) {
                      validator.getCacheControl(part.providerOptions, {
                        type: "thinking block",
                        canCache: false
                      });
                      anthropicContent.push({
                        type: "thinking",
                        thinking: part.text,
                        signature: reasoningMetadata.signature
                      });
                    } else if (reasoningMetadata.redactedData != null) {
                      validator.getCacheControl(part.providerOptions, {
                        type: "redacted thinking block",
                        canCache: false
                      });
                      anthropicContent.push({
                        type: "redacted_thinking",
                        data: reasoningMetadata.redactedData
                      });
                    } else {
                      warnings.push({
                        type: "other",
                        message: "unsupported reasoning metadata"
                      });
                    }
                  } else {
                    warnings.push({
                      type: "other",
                      message: "unsupported reasoning metadata"
                    });
                  }
                } else {
                  warnings.push({
                    type: "other",
                    message: "sending reasoning content is disabled for this model"
                  });
                }
                break;
              }
              case "tool-call": {
                if (part.providerExecuted) {
                  if (part.toolName === "code_execution" && part.input != null && typeof part.input === "object" && "type" in part.input && typeof part.input.type === "string" && (part.input.type === "bash_code_execution" || part.input.type === "text_editor_code_execution")) {
                    anthropicContent.push({
                      type: "server_tool_use",
                      id: part.toolCallId,
                      name: part.input.type,
                      // map back to subtool name
                      input: part.input,
                      cache_control: cacheControl
                    });
                  } else if (part.toolName === "code_execution" || // code execution 20250522
                  part.toolName === "web_fetch" || part.toolName === "web_search") {
                    anthropicContent.push({
                      type: "server_tool_use",
                      id: part.toolCallId,
                      name: part.toolName,
                      input: part.input,
                      cache_control: cacheControl
                    });
                  } else {
                    warnings.push({
                      type: "other",
                      message: `provider executed tool call for tool ${part.toolName} is not supported`
                    });
                  }
                  break;
                }
                anthropicContent.push({
                  type: "tool_use",
                  id: part.toolCallId,
                  name: part.toolName,
                  input: part.input,
                  cache_control: cacheControl
                });
                break;
              }
              case "tool-result": {
                if (part.toolName === "code_execution") {
                  const output = part.output;
                  if (output.type !== "json") {
                    warnings.push({
                      type: "other",
                      message: `provider executed tool result output type ${output.type} for tool ${part.toolName} is not supported`
                    });
                    break;
                  }
                  if (output.value == null || typeof output.value !== "object" || !("type" in output.value) || typeof output.value.type !== "string") {
                    warnings.push({
                      type: "other",
                      message: `provider executed tool result output value is not a valid code execution result for tool ${part.toolName}`
                    });
                    break;
                  }
                  if (output.value.type === "code_execution_result") {
                    const codeExecutionOutput = await (0, import_provider_utils10.validateTypes)({
                      value: output.value,
                      schema: codeExecution_20250522OutputSchema
                    });
                    anthropicContent.push({
                      type: "code_execution_tool_result",
                      tool_use_id: part.toolCallId,
                      content: {
                        type: codeExecutionOutput.type,
                        stdout: codeExecutionOutput.stdout,
                        stderr: codeExecutionOutput.stderr,
                        return_code: codeExecutionOutput.return_code
                      },
                      cache_control: cacheControl
                    });
                  } else {
                    const codeExecutionOutput = await (0, import_provider_utils10.validateTypes)({
                      value: output.value,
                      schema: codeExecution_20250825OutputSchema
                    });
                    anthropicContent.push(
                      codeExecutionOutput.type === "bash_code_execution_result" || codeExecutionOutput.type === "bash_code_execution_tool_result_error" ? {
                        type: "bash_code_execution_tool_result",
                        tool_use_id: part.toolCallId,
                        cache_control: cacheControl,
                        content: codeExecutionOutput
                      } : {
                        type: "text_editor_code_execution_tool_result",
                        tool_use_id: part.toolCallId,
                        cache_control: cacheControl,
                        content: codeExecutionOutput
                      }
                    );
                  }
                  break;
                }
                if (part.toolName === "web_fetch") {
                  const output = part.output;
                  if (output.type !== "json") {
                    warnings.push({
                      type: "other",
                      message: `provider executed tool result output type ${output.type} for tool ${part.toolName} is not supported`
                    });
                    break;
                  }
                  const webFetchOutput = await (0, import_provider_utils10.validateTypes)({
                    value: output.value,
                    schema: webFetch_20250910OutputSchema
                  });
                  anthropicContent.push({
                    type: "web_fetch_tool_result",
                    tool_use_id: part.toolCallId,
                    content: {
                      type: "web_fetch_result",
                      url: webFetchOutput.url,
                      retrieved_at: webFetchOutput.retrievedAt,
                      content: {
                        type: "document",
                        title: webFetchOutput.content.title,
                        citations: webFetchOutput.content.citations,
                        source: {
                          type: webFetchOutput.content.source.type,
                          media_type: webFetchOutput.content.source.mediaType,
                          data: webFetchOutput.content.source.data
                        }
                      }
                    },
                    cache_control: cacheControl
                  });
                  break;
                }
                if (part.toolName === "web_search") {
                  const output = part.output;
                  if (output.type !== "json") {
                    warnings.push({
                      type: "other",
                      message: `provider executed tool result output type ${output.type} for tool ${part.toolName} is not supported`
                    });
                    break;
                  }
                  const webSearchOutput = await (0, import_provider_utils10.validateTypes)({
                    value: output.value,
                    schema: webSearch_20250305OutputSchema
                  });
                  anthropicContent.push({
                    type: "web_search_tool_result",
                    tool_use_id: part.toolCallId,
                    content: webSearchOutput.map((result) => ({
                      url: result.url,
                      title: result.title,
                      page_age: result.pageAge,
                      encrypted_content: result.encryptedContent,
                      type: result.type
                    })),
                    cache_control: cacheControl
                  });
                  break;
                }
                warnings.push({
                  type: "other",
                  message: `provider executed tool result for tool ${part.toolName} is not supported`
                });
                break;
              }
            }
          }
        }
        messages.push({ role: "assistant", content: anthropicContent });
        break;
      }
      default: {
        const _exhaustiveCheck = type;
        throw new Error(`content type: ${_exhaustiveCheck}`);
      }
    }
  }
  return {
    prompt: { system, messages },
    betas
  };
}
function groupIntoBlocks(prompt) {
  const blocks = [];
  let currentBlock = void 0;
  for (const message of prompt) {
    const { role } = message;
    switch (role) {
      case "system": {
        if ((currentBlock == null ? void 0 : currentBlock.type) !== "system") {
          currentBlock = { type: "system", messages: [] };
          blocks.push(currentBlock);
        }
        currentBlock.messages.push(message);
        break;
      }
      case "assistant": {
        if ((currentBlock == null ? void 0 : currentBlock.type) !== "assistant") {
          currentBlock = { type: "assistant", messages: [] };
          blocks.push(currentBlock);
        }
        currentBlock.messages.push(message);
        break;
      }
      case "user": {
        if ((currentBlock == null ? void 0 : currentBlock.type) !== "user") {
          currentBlock = { type: "user", messages: [] };
          blocks.push(currentBlock);
        }
        currentBlock.messages.push(message);
        break;
      }
      case "tool": {
        if ((currentBlock == null ? void 0 : currentBlock.type) !== "user") {
          currentBlock = { type: "user", messages: [] };
          blocks.push(currentBlock);
        }
        currentBlock.messages.push(message);
        break;
      }
      default: {
        const _exhaustiveCheck = role;
        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
      }
    }
  }
  return blocks;
}

// src/map-anthropic-stop-reason.ts
function mapAnthropicStopReason({
  finishReason,
  isJsonResponseFromTool
}) {
  switch (finishReason) {
    case "pause_turn":
    case "end_turn":
    case "stop_sequence":
      return "stop";
    case "refusal":
      return "content-filter";
    case "tool_use":
      return isJsonResponseFromTool ? "stop" : "tool-calls";
    case "max_tokens":
      return "length";
    default:
      return "unknown";
  }
}

// src/anthropic-messages-language-model.ts
function createCitationSource(citation, citationDocuments, generateId3) {
  var _a;
  if (citation.type !== "page_location" && citation.type !== "char_location") {
    return;
  }
  const documentInfo = citationDocuments[citation.document_index];
  if (!documentInfo) {
    return;
  }
  return {
    type: "source",
    sourceType: "document",
    id: generateId3(),
    mediaType: documentInfo.mediaType,
    title: (_a = citation.document_title) != null ? _a : documentInfo.title,
    filename: documentInfo.filename,
    providerMetadata: {
      anthropic: citation.type === "page_location" ? {
        citedText: citation.cited_text,
        startPageNumber: citation.start_page_number,
        endPageNumber: citation.end_page_number
      } : {
        citedText: citation.cited_text,
        startCharIndex: citation.start_char_index,
        endCharIndex: citation.end_char_index
      }
    }
  };
}
var AnthropicMessagesLanguageModel = class {
  constructor(modelId, config) {
    this.specificationVersion = "v2";
    var _a;
    this.modelId = modelId;
    this.config = config;
    this.generateId = (_a = config.generateId) != null ? _a : import_provider_utils11.generateId;
  }
  supportsUrl(url) {
    return url.protocol === "https:";
  }
  get provider() {
    return this.config.provider;
  }
  get supportedUrls() {
    var _a, _b, _c;
    return (_c = (_b = (_a = this.config).supportedUrls) == null ? void 0 : _b.call(_a)) != null ? _c : {};
  }
  async getArgs({
    prompt,
    maxOutputTokens,
    temperature,
    topP,
    topK,
    frequencyPenalty,
    presencePenalty,
    stopSequences,
    responseFormat,
    seed,
    tools,
    toolChoice,
    providerOptions
  }) {
    var _a, _b, _c, _d;
    const warnings = [];
    if (frequencyPenalty != null) {
      warnings.push({
        type: "unsupported-setting",
        setting: "frequencyPenalty"
      });
    }
    if (presencePenalty != null) {
      warnings.push({
        type: "unsupported-setting",
        setting: "presencePenalty"
      });
    }
    if (seed != null) {
      warnings.push({
        type: "unsupported-setting",
        setting: "seed"
      });
    }
    if ((responseFormat == null ? void 0 : responseFormat.type) === "json") {
      if (responseFormat.schema == null) {
        warnings.push({
          type: "unsupported-setting",
          setting: "responseFormat",
          details: "JSON response format requires a schema. The response format is ignored."
        });
      } else if (tools != null) {
        warnings.push({
          type: "unsupported-setting",
          setting: "tools",
          details: "JSON response format does not support tools. The provided tools are ignored."
        });
      }
    }
    const jsonResponseTool = (responseFormat == null ? void 0 : responseFormat.type) === "json" && responseFormat.schema != null ? {
      type: "function",
      name: "json",
      description: "Respond with a JSON object.",
      inputSchema: responseFormat.schema
    } : void 0;
    const anthropicOptions = await (0, import_provider_utils11.parseProviderOptions)({
      provider: "anthropic",
      providerOptions,
      schema: anthropicProviderOptions
    });
    const cacheControlValidator = new CacheControlValidator();
    const { prompt: messagesPrompt, betas } = await convertToAnthropicMessagesPrompt({
      prompt,
      sendReasoning: (_a = anthropicOptions == null ? void 0 : anthropicOptions.sendReasoning) != null ? _a : true,
      warnings,
      cacheControlValidator
    });
    const isThinking = ((_b = anthropicOptions == null ? void 0 : anthropicOptions.thinking) == null ? void 0 : _b.type) === "enabled";
    const thinkingBudget = (_c = anthropicOptions == null ? void 0 : anthropicOptions.thinking) == null ? void 0 : _c.budgetTokens;
    const maxOutputTokensForModel = getMaxOutputTokensForModel(this.modelId);
    const maxTokens = maxOutputTokens != null ? maxOutputTokens : maxOutputTokensForModel;
    const baseArgs = {
      // model id:
      model: this.modelId,
      // standardized settings:
      max_tokens: maxTokens,
      temperature,
      top_k: topK,
      top_p: topP,
      stop_sequences: stopSequences,
      // provider specific settings:
      ...isThinking && {
        thinking: { type: "enabled", budget_tokens: thinkingBudget }
      },
      // container with agent skills:
      ...(anthropicOptions == null ? void 0 : anthropicOptions.container) && {
        container: {
          id: anthropicOptions.container.id,
          skills: (_d = anthropicOptions.container.skills) == null ? void 0 : _d.map((skill) => ({
            type: skill.type,
            skill_id: skill.skillId,
            version: skill.version
          }))
        }
      },
      // prompt:
      system: messagesPrompt.system,
      messages: messagesPrompt.messages
    };
    if (isThinking) {
      if (thinkingBudget == null) {
        throw new import_provider3.UnsupportedFunctionalityError({
          functionality: "thinking requires a budget"
        });
      }
      if (baseArgs.temperature != null) {
        baseArgs.temperature = void 0;
        warnings.push({
          type: "unsupported-setting",
          setting: "temperature",
          details: "temperature is not supported when thinking is enabled"
        });
      }
      if (topK != null) {
        baseArgs.top_k = void 0;
        warnings.push({
          type: "unsupported-setting",
          setting: "topK",
          details: "topK is not supported when thinking is enabled"
        });
      }
      if (topP != null) {
        baseArgs.top_p = void 0;
        warnings.push({
          type: "unsupported-setting",
          setting: "topP",
          details: "topP is not supported when thinking is enabled"
        });
      }
      baseArgs.max_tokens = maxTokens + thinkingBudget;
    }
    if (baseArgs.max_tokens > maxOutputTokensForModel) {
      if (maxOutputTokens != null) {
        warnings.push({
          type: "unsupported-setting",
          setting: "maxOutputTokens",
          details: `${baseArgs.max_tokens} (maxOutputTokens + thinkingBudget) is greater than ${this.modelId} ${maxOutputTokensForModel} max output tokens. The max output tokens have been limited to ${maxOutputTokensForModel}.`
        });
      }
      baseArgs.max_tokens = maxOutputTokensForModel;
    }
    if ((anthropicOptions == null ? void 0 : anthropicOptions.container) && anthropicOptions.container.skills && anthropicOptions.container.skills.length > 0) {
      betas.add("code-execution-2025-08-25");
      betas.add("skills-2025-10-02");
      betas.add("files-api-2025-04-14");
      if (!(tools == null ? void 0 : tools.some(
        (tool) => tool.type === "provider-defined" && tool.id === "anthropic.code_execution_20250825"
      ))) {
        warnings.push({
          type: "other",
          message: "code execution tool is required when using skills"
        });
      }
    }
    const {
      tools: anthropicTools2,
      toolChoice: anthropicToolChoice,
      toolWarnings,
      betas: toolsBetas
    } = await prepareTools(
      jsonResponseTool != null ? {
        tools: [jsonResponseTool],
        toolChoice: { type: "tool", toolName: jsonResponseTool.name },
        disableParallelToolUse: true,
        cacheControlValidator
      } : {
        tools: tools != null ? tools : [],
        toolChoice,
        disableParallelToolUse: anthropicOptions == null ? void 0 : anthropicOptions.disableParallelToolUse,
        cacheControlValidator
      }
    );
    const cacheWarnings = cacheControlValidator.getWarnings();
    return {
      args: {
        ...baseArgs,
        tools: anthropicTools2,
        tool_choice: anthropicToolChoice
      },
      warnings: [...warnings, ...toolWarnings, ...cacheWarnings],
      betas: /* @__PURE__ */ new Set([...betas, ...toolsBetas]),
      usesJsonResponseTool: jsonResponseTool != null
    };
  }
  async getHeaders({
    betas,
    headers
  }) {
    return (0, import_provider_utils11.combineHeaders)(
      await (0, import_provider_utils11.resolve)(this.config.headers),
      betas.size > 0 ? { "anthropic-beta": Array.from(betas).join(",") } : {},
      headers
    );
  }
  buildRequestUrl(isStreaming) {
    var _a, _b, _c;
    return (_c = (_b = (_a = this.config).buildRequestUrl) == null ? void 0 : _b.call(_a, this.config.baseURL, isStreaming)) != null ? _c : `${this.config.baseURL}/messages`;
  }
  transformRequestBody(args) {
    var _a, _b, _c;
    return (_c = (_b = (_a = this.config).transformRequestBody) == null ? void 0 : _b.call(_a, args)) != null ? _c : args;
  }
  extractCitationDocuments(prompt) {
    const isCitationPart = (part) => {
      var _a, _b;
      if (part.type !== "file") {
        return false;
      }
      if (part.mediaType !== "application/pdf" && part.mediaType !== "text/plain") {
        return false;
      }
      const anthropic2 = (_a = part.providerOptions) == null ? void 0 : _a.anthropic;
      const citationsConfig = anthropic2 == null ? void 0 : anthropic2.citations;
      return (_b = citationsConfig == null ? void 0 : citationsConfig.enabled) != null ? _b : false;
    };
    return prompt.filter((message) => message.role === "user").flatMap((message) => message.content).filter(isCitationPart).map((part) => {
      var _a;
      const filePart = part;
      return {
        title: (_a = filePart.filename) != null ? _a : "Untitled Document",
        filename: filePart.filename,
        mediaType: filePart.mediaType
      };
    });
  }
  async doGenerate(options) {
    var _a, _b, _c, _d, _e, _f;
    const { args, warnings, betas, usesJsonResponseTool } = await this.getArgs(options);
    const citationDocuments = this.extractCitationDocuments(options.prompt);
    const {
      responseHeaders,
      value: response,
      rawValue: rawResponse
    } = await (0, import_provider_utils11.postJsonToApi)({
      url: this.buildRequestUrl(false),
      headers: await this.getHeaders({ betas, headers: options.headers }),
      body: this.transformRequestBody(args),
      failedResponseHandler: anthropicFailedResponseHandler,
      successfulResponseHandler: (0, import_provider_utils11.createJsonResponseHandler)(
        anthropicMessagesResponseSchema
      ),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    const content = [];
    for (const part of response.content) {
      switch (part.type) {
        case "text": {
          if (!usesJsonResponseTool) {
            content.push({ type: "text", text: part.text });
            if (part.citations) {
              for (const citation of part.citations) {
                const source = createCitationSource(
                  citation,
                  citationDocuments,
                  this.generateId
                );
                if (source) {
                  content.push(source);
                }
              }
            }
          }
          break;
        }
        case "thinking": {
          content.push({
            type: "reasoning",
            text: part.thinking,
            providerMetadata: {
              anthropic: {
                signature: part.signature
              }
            }
          });
          break;
        }
        case "redacted_thinking": {
          content.push({
            type: "reasoning",
            text: "",
            providerMetadata: {
              anthropic: {
                redactedData: part.data
              }
            }
          });
          break;
        }
        case "tool_use": {
          content.push(
            // when a json response tool is used, the tool call becomes the text:
            usesJsonResponseTool ? {
              type: "text",
              text: JSON.stringify(part.input)
            } : {
              type: "tool-call",
              toolCallId: part.id,
              toolName: part.name,
              input: JSON.stringify(part.input)
            }
          );
          break;
        }
        case "server_tool_use": {
          if (part.name === "text_editor_code_execution" || part.name === "bash_code_execution") {
            content.push({
              type: "tool-call",
              toolCallId: part.id,
              toolName: "code_execution",
              input: JSON.stringify({ type: part.name, ...part.input }),
              providerExecuted: true
            });
          } else if (part.name === "web_search" || part.name === "code_execution" || part.name === "web_fetch") {
            content.push({
              type: "tool-call",
              toolCallId: part.id,
              toolName: part.name,
              input: JSON.stringify(part.input),
              providerExecuted: true
            });
          }
          break;
        }
        case "web_fetch_tool_result": {
          if (part.content.type === "web_fetch_result") {
            content.push({
              type: "tool-result",
              toolCallId: part.tool_use_id,
              toolName: "web_fetch",
              result: {
                type: "web_fetch_result",
                url: part.content.url,
                retrievedAt: part.content.retrieved_at,
                content: {
                  type: part.content.content.type,
                  title: part.content.content.title,
                  citations: part.content.content.citations,
                  source: {
                    type: part.content.content.source.type,
                    mediaType: part.content.content.source.media_type,
                    data: part.content.content.source.data
                  }
                }
              },
              providerExecuted: true
            });
          } else if (part.content.type === "web_fetch_tool_result_error") {
            content.push({
              type: "tool-result",
              toolCallId: part.tool_use_id,
              toolName: "web_fetch",
              isError: true,
              result: {
                type: "web_fetch_tool_result_error",
                errorCode: part.content.error_code
              },
              providerExecuted: true
            });
          }
          break;
        }
        case "web_search_tool_result": {
          if (Array.isArray(part.content)) {
            content.push({
              type: "tool-result",
              toolCallId: part.tool_use_id,
              toolName: "web_search",
              result: part.content.map((result) => {
                var _a2;
                return {
                  url: result.url,
                  title: result.title,
                  pageAge: (_a2 = result.page_age) != null ? _a2 : null,
                  encryptedContent: result.encrypted_content,
                  type: result.type
                };
              }),
              providerExecuted: true
            });
            for (const result of part.content) {
              content.push({
                type: "source",
                sourceType: "url",
                id: this.generateId(),
                url: result.url,
                title: result.title,
                providerMetadata: {
                  anthropic: {
                    pageAge: (_a = result.page_age) != null ? _a : null
                  }
                }
              });
            }
          } else {
            content.push({
              type: "tool-result",
              toolCallId: part.tool_use_id,
              toolName: "web_search",
              isError: true,
              result: {
                type: "web_search_tool_result_error",
                errorCode: part.content.error_code
              },
              providerExecuted: true
            });
          }
          break;
        }
        // code execution 20250522:
        case "code_execution_tool_result": {
          if (part.content.type === "code_execution_result") {
            content.push({
              type: "tool-result",
              toolCallId: part.tool_use_id,
              toolName: "code_execution",
              result: {
                type: part.content.type,
                stdout: part.content.stdout,
                stderr: part.content.stderr,
                return_code: part.content.return_code
              },
              providerExecuted: true
            });
          } else if (part.content.type === "code_execution_tool_result_error") {
            content.push({
              type: "tool-result",
              toolCallId: part.tool_use_id,
              toolName: "code_execution",
              isError: true,
              result: {
                type: "code_execution_tool_result_error",
                errorCode: part.content.error_code
              },
              providerExecuted: true
            });
          }
          break;
        }
        // code execution 20250825:
        case "bash_code_execution_tool_result":
        case "text_editor_code_execution_tool_result": {
          content.push({
            type: "tool-result",
            toolCallId: part.tool_use_id,
            toolName: "code_execution",
            result: part.content,
            providerExecuted: true
          });
          break;
        }
      }
    }
    return {
      content,
      finishReason: mapAnthropicStopReason({
        finishReason: response.stop_reason,
        isJsonResponseFromTool: usesJsonResponseTool
      }),
      usage: {
        inputTokens: response.usage.input_tokens,
        outputTokens: response.usage.output_tokens,
        totalTokens: response.usage.input_tokens + response.usage.output_tokens,
        cachedInputTokens: (_b = response.usage.cache_read_input_tokens) != null ? _b : void 0
      },
      request: { body: args },
      response: {
        id: (_c = response.id) != null ? _c : void 0,
        modelId: (_d = response.model) != null ? _d : void 0,
        headers: responseHeaders,
        body: rawResponse
      },
      warnings,
      providerMetadata: {
        anthropic: {
          usage: response.usage,
          cacheCreationInputTokens: (_e = response.usage.cache_creation_input_tokens) != null ? _e : null,
          stopSequence: (_f = response.stop_sequence) != null ? _f : null
        }
      }
    };
  }
  async doStream(options) {
    const { args, warnings, betas, usesJsonResponseTool } = await this.getArgs(options);
    const citationDocuments = this.extractCitationDocuments(options.prompt);
    const body = { ...args, stream: true };
    const { responseHeaders, value: response } = await (0, import_provider_utils11.postJsonToApi)({
      url: this.buildRequestUrl(true),
      headers: await this.getHeaders({ betas, headers: options.headers }),
      body: this.transformRequestBody(body),
      failedResponseHandler: anthropicFailedResponseHandler,
      successfulResponseHandler: (0, import_provider_utils11.createEventSourceResponseHandler)(
        anthropicMessagesChunkSchema
      ),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    let finishReason = "unknown";
    const usage = {
      inputTokens: void 0,
      outputTokens: void 0,
      totalTokens: void 0
    };
    const contentBlocks = {};
    let rawUsage = void 0;
    let cacheCreationInputTokens = null;
    let stopSequence = null;
    let blockType = void 0;
    const generateId3 = this.generateId;
    return {
      stream: response.pipeThrough(
        new TransformStream({
          start(controller) {
            controller.enqueue({ type: "stream-start", warnings });
          },
          transform(chunk, controller) {
            var _a, _b, _c, _d, _e, _f, _g, _h;
            if (options.includeRawChunks) {
              controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
            }
            if (!chunk.success) {
              controller.enqueue({ type: "error", error: chunk.error });
              return;
            }
            const value = chunk.value;
            switch (value.type) {
              case "ping": {
                return;
              }
              case "content_block_start": {
                const contentBlockType = value.content_block.type;
                blockType = contentBlockType;
                switch (contentBlockType) {
                  case "text": {
                    contentBlocks[value.index] = { type: "text" };
                    controller.enqueue({
                      type: "text-start",
                      id: String(value.index)
                    });
                    return;
                  }
                  case "thinking": {
                    contentBlocks[value.index] = { type: "reasoning" };
                    controller.enqueue({
                      type: "reasoning-start",
                      id: String(value.index)
                    });
                    return;
                  }
                  case "redacted_thinking": {
                    contentBlocks[value.index] = { type: "reasoning" };
                    controller.enqueue({
                      type: "reasoning-start",
                      id: String(value.index),
                      providerMetadata: {
                        anthropic: {
                          redactedData: value.content_block.data
                        }
                      }
                    });
                    return;
                  }
                  case "tool_use": {
                    contentBlocks[value.index] = usesJsonResponseTool ? { type: "text" } : {
                      type: "tool-call",
                      toolCallId: value.content_block.id,
                      toolName: value.content_block.name,
                      input: "",
                      firstDelta: true
                    };
                    controller.enqueue(
                      usesJsonResponseTool ? { type: "text-start", id: String(value.index) } : {
                        type: "tool-input-start",
                        id: value.content_block.id,
                        toolName: value.content_block.name
                      }
                    );
                    return;
                  }
                  case "server_tool_use": {
                    if ([
                      "web_fetch",
                      "web_search",
                      // code execution 20250825:
                      "code_execution",
                      // code execution 20250825 text editor:
                      "text_editor_code_execution",
                      // code execution 20250825 bash:
                      "bash_code_execution"
                    ].includes(value.content_block.name)) {
                      contentBlocks[value.index] = {
                        type: "tool-call",
                        toolCallId: value.content_block.id,
                        toolName: value.content_block.name,
                        input: "",
                        providerExecuted: true,
                        firstDelta: true
                      };
                      const mappedToolName = value.content_block.name === "text_editor_code_execution" || value.content_block.name === "bash_code_execution" ? "code_execution" : value.content_block.name;
                      controller.enqueue({
                        type: "tool-input-start",
                        id: value.content_block.id,
                        toolName: mappedToolName,
                        providerExecuted: true
                      });
                    }
                    return;
                  }
                  case "web_fetch_tool_result": {
                    const part = value.content_block;
                    if (part.content.type === "web_fetch_result") {
                      controller.enqueue({
                        type: "tool-result",
                        toolCallId: part.tool_use_id,
                        toolName: "web_fetch",
                        result: {
                          type: "web_fetch_result",
                          url: part.content.url,
                          retrievedAt: part.content.retrieved_at,
                          content: {
                            type: part.content.content.type,
                            title: part.content.content.title,
                            citations: part.content.content.citations,
                            source: {
                              type: part.content.content.source.type,
                              mediaType: part.content.content.source.media_type,
                              data: part.content.content.source.data
                            }
                          }
                        }
                      });
                    } else if (part.content.type === "web_fetch_tool_result_error") {
                      controller.enqueue({
                        type: "tool-result",
                        toolCallId: part.tool_use_id,
                        toolName: "web_fetch",
                        isError: true,
                        result: {
                          type: "web_fetch_tool_result_error",
                          errorCode: part.content.error_code
                        },
                        providerExecuted: true
                      });
                    }
                    return;
                  }
                  case "web_search_tool_result": {
                    const part = value.content_block;
                    if (Array.isArray(part.content)) {
                      controller.enqueue({
                        type: "tool-result",
                        toolCallId: part.tool_use_id,
                        toolName: "web_search",
                        result: part.content.map((result) => {
                          var _a2;
                          return {
                            url: result.url,
                            title: result.title,
                            pageAge: (_a2 = result.page_age) != null ? _a2 : null,
                            encryptedContent: result.encrypted_content,
                            type: result.type
                          };
                        }),
                        providerExecuted: true
                      });
                      for (const result of part.content) {
                        controller.enqueue({
                          type: "source",
                          sourceType: "url",
                          id: generateId3(),
                          url: result.url,
                          title: result.title,
                          providerMetadata: {
                            anthropic: {
                              pageAge: (_a = result.page_age) != null ? _a : null
                            }
                          }
                        });
                      }
                    } else {
                      controller.enqueue({
                        type: "tool-result",
                        toolCallId: part.tool_use_id,
                        toolName: "web_search",
                        isError: true,
                        result: {
                          type: "web_search_tool_result_error",
                          errorCode: part.content.error_code
                        },
                        providerExecuted: true
                      });
                    }
                    return;
                  }
                  // code execution 20250522:
                  case "code_execution_tool_result": {
                    const part = value.content_block;
                    if (part.content.type === "code_execution_result") {
                      controller.enqueue({
                        type: "tool-result",
                        toolCallId: part.tool_use_id,
                        toolName: "code_execution",
                        result: {
                          type: part.content.type,
                          stdout: part.content.stdout,
                          stderr: part.content.stderr,
                          return_code: part.content.return_code
                        },
                        providerExecuted: true
                      });
                    } else if (part.content.type === "code_execution_tool_result_error") {
                      controller.enqueue({
                        type: "tool-result",
                        toolCallId: part.tool_use_id,
                        toolName: "code_execution",
                        isError: true,
                        result: {
                          type: "code_execution_tool_result_error",
                          errorCode: part.content.error_code
                        },
                        providerExecuted: true
                      });
                    }
                    return;
                  }
                  // code execution 20250825:
                  case "bash_code_execution_tool_result":
                  case "text_editor_code_execution_tool_result": {
                    const part = value.content_block;
                    controller.enqueue({
                      type: "tool-result",
                      toolCallId: part.tool_use_id,
                      toolName: "code_execution",
                      result: part.content,
                      providerExecuted: true
                    });
                    return;
                  }
                  default: {
                    const _exhaustiveCheck = contentBlockType;
                    throw new Error(
                      `Unsupported content block type: ${_exhaustiveCheck}`
                    );
                  }
                }
              }
              case "content_block_stop": {
                if (contentBlocks[value.index] != null) {
                  const contentBlock = contentBlocks[value.index];
                  switch (contentBlock.type) {
                    case "text": {
                      controller.enqueue({
                        type: "text-end",
                        id: String(value.index)
                      });
                      break;
                    }
                    case "reasoning": {
                      controller.enqueue({
                        type: "reasoning-end",
                        id: String(value.index)
                      });
                      break;
                    }
                    case "tool-call":
                      if (!usesJsonResponseTool) {
                        controller.enqueue({
                          type: "tool-input-end",
                          id: contentBlock.toolCallId
                        });
                        const toolName = contentBlock.toolName === "text_editor_code_execution" || contentBlock.toolName === "bash_code_execution" ? "code_execution" : contentBlock.toolName;
                        controller.enqueue({
                          type: "tool-call",
                          toolCallId: contentBlock.toolCallId,
                          toolName,
                          input: contentBlock.input,
                          providerExecuted: contentBlock.providerExecuted
                        });
                      }
                      break;
                  }
                  delete contentBlocks[value.index];
                }
                blockType = void 0;
                return;
              }
              case "content_block_delta": {
                const deltaType = value.delta.type;
                switch (deltaType) {
                  case "text_delta": {
                    if (usesJsonResponseTool) {
                      return;
                    }
                    controller.enqueue({
                      type: "text-delta",
                      id: String(value.index),
                      delta: value.delta.text
                    });
                    return;
                  }
                  case "thinking_delta": {
                    controller.enqueue({
                      type: "reasoning-delta",
                      id: String(value.index),
                      delta: value.delta.thinking
                    });
                    return;
                  }
                  case "signature_delta": {
                    if (blockType === "thinking") {
                      controller.enqueue({
                        type: "reasoning-delta",
                        id: String(value.index),
                        delta: "",
                        providerMetadata: {
                          anthropic: {
                            signature: value.delta.signature
                          }
                        }
                      });
                    }
                    return;
                  }
                  case "input_json_delta": {
                    const contentBlock = contentBlocks[value.index];
                    let delta = value.delta.partial_json;
                    if (delta.length === 0) {
                      return;
                    }
                    if (usesJsonResponseTool) {
                      if ((contentBlock == null ? void 0 : contentBlock.type) !== "text") {
                        return;
                      }
                      controller.enqueue({
                        type: "text-delta",
                        id: String(value.index),
                        delta
                      });
                    } else {
                      if ((contentBlock == null ? void 0 : contentBlock.type) !== "tool-call") {
                        return;
                      }
                      if (contentBlock.firstDelta && (contentBlock.toolName === "bash_code_execution" || contentBlock.toolName === "text_editor_code_execution")) {
                        delta = `{"type": "${contentBlock.toolName}",${delta.substring(1)}`;
                      }
                      controller.enqueue({
                        type: "tool-input-delta",
                        id: contentBlock.toolCallId,
                        delta
                      });
                      contentBlock.input += delta;
                      contentBlock.firstDelta = false;
                    }
                    return;
                  }
                  case "citations_delta": {
                    const citation = value.delta.citation;
                    const source = createCitationSource(
                      citation,
                      citationDocuments,
                      generateId3
                    );
                    if (source) {
                      controller.enqueue(source);
                    }
                    return;
                  }
                  default: {
                    const _exhaustiveCheck = deltaType;
                    throw new Error(
                      `Unsupported delta type: ${_exhaustiveCheck}`
                    );
                  }
                }
              }
              case "message_start": {
                usage.inputTokens = value.message.usage.input_tokens;
                usage.cachedInputTokens = (_b = value.message.usage.cache_read_input_tokens) != null ? _b : void 0;
                rawUsage = {
                  ...value.message.usage
                };
                cacheCreationInputTokens = (_c = value.message.usage.cache_creation_input_tokens) != null ? _c : null;
                controller.enqueue({
                  type: "response-metadata",
                  id: (_d = value.message.id) != null ? _d : void 0,
                  modelId: (_e = value.message.model) != null ? _e : void 0
                });
                return;
              }
              case "message_delta": {
                usage.outputTokens = value.usage.output_tokens;
                usage.totalTokens = ((_f = usage.inputTokens) != null ? _f : 0) + ((_g = value.usage.output_tokens) != null ? _g : 0);
                finishReason = mapAnthropicStopReason({
                  finishReason: value.delta.stop_reason,
                  isJsonResponseFromTool: usesJsonResponseTool
                });
                stopSequence = (_h = value.delta.stop_sequence) != null ? _h : null;
                rawUsage = {
                  ...rawUsage,
                  ...value.usage
                };
                return;
              }
              case "message_stop": {
                controller.enqueue({
                  type: "finish",
                  finishReason,
                  usage,
                  providerMetadata: {
                    anthropic: {
                      usage: rawUsage != null ? rawUsage : null,
                      cacheCreationInputTokens,
                      stopSequence
                    }
                  }
                });
                return;
              }
              case "error": {
                controller.enqueue({ type: "error", error: value.error });
                return;
              }
              default: {
                const _exhaustiveCheck = value;
                throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);
              }
            }
          }
        })
      ),
      request: { body },
      response: { headers: responseHeaders }
    };
  }
};
function getMaxOutputTokensForModel(modelId) {
  if (modelId.includes("claude-sonnet-4-") || modelId.includes("claude-3-7-sonnet") || modelId.includes("claude-haiku-4-5")) {
    return 64e3;
  } else if (modelId.includes("claude-opus-4-")) {
    return 32e3;
  } else if (modelId.includes("claude-3-5-haiku")) {
    return 8192;
  } else {
    return 4096;
  }
}

// src/tool/bash_20241022.ts
var import_provider_utils12 = require("@ai-sdk/provider-utils");
var import_v49 = require("zod/v4");
var bash_20241022InputSchema = (0, import_provider_utils12.lazySchema)(
  () => (0, import_provider_utils12.zodSchema)(
    import_v49.z.object({
      command: import_v49.z.string(),
      restart: import_v49.z.boolean().optional()
    })
  )
);
var bash_20241022 = (0, import_provider_utils12.createProviderDefinedToolFactory)({
  id: "anthropic.bash_20241022",
  name: "bash",
  inputSchema: bash_20241022InputSchema
});

// src/tool/bash_20250124.ts
var import_provider_utils13 = require("@ai-sdk/provider-utils");
var import_v410 = require("zod/v4");
var bash_20250124InputSchema = (0, import_provider_utils13.lazySchema)(
  () => (0, import_provider_utils13.zodSchema)(
    import_v410.z.object({
      command: import_v410.z.string(),
      restart: import_v410.z.boolean().optional()
    })
  )
);
var bash_20250124 = (0, import_provider_utils13.createProviderDefinedToolFactory)({
  id: "anthropic.bash_20250124",
  name: "bash",
  inputSchema: bash_20250124InputSchema
});

// src/tool/computer_20241022.ts
var import_provider_utils14 = require("@ai-sdk/provider-utils");
var import_v411 = require("zod/v4");
var computer_20241022InputSchema = (0, import_provider_utils14.lazySchema)(
  () => (0, import_provider_utils14.zodSchema)(
    import_v411.z.object({
      action: import_v411.z.enum([
        "key",
        "type",
        "mouse_move",
        "left_click",
        "left_click_drag",
        "right_click",
        "middle_click",
        "double_click",
        "screenshot",
        "cursor_position"
      ]),
      coordinate: import_v411.z.array(import_v411.z.number().int()).optional(),
      text: import_v411.z.string().optional()
    })
  )
);
var computer_20241022 = (0, import_provider_utils14.createProviderDefinedToolFactory)({
  id: "anthropic.computer_20241022",
  name: "computer",
  inputSchema: computer_20241022InputSchema
});

// src/tool/computer_20250124.ts
var import_provider_utils15 = require("@ai-sdk/provider-utils");
var import_v412 = require("zod/v4");
var computer_20250124InputSchema = (0, import_provider_utils15.lazySchema)(
  () => (0, import_provider_utils15.zodSchema)(
    import_v412.z.object({
      action: import_v412.z.enum([
        "key",
        "hold_key",
        "type",
        "cursor_position",
        "mouse_move",
        "left_mouse_down",
        "left_mouse_up",
        "left_click",
        "left_click_drag",
        "right_click",
        "middle_click",
        "double_click",
        "triple_click",
        "scroll",
        "wait",
        "screenshot"
      ]),
      coordinate: import_v412.z.tuple([import_v412.z.number().int(), import_v412.z.number().int()]).optional(),
      duration: import_v412.z.number().optional(),
      scroll_amount: import_v412.z.number().optional(),
      scroll_direction: import_v412.z.enum(["up", "down", "left", "right"]).optional(),
      start_coordinate: import_v412.z.tuple([import_v412.z.number().int(), import_v412.z.number().int()]).optional(),
      text: import_v412.z.string().optional()
    })
  )
);
var computer_20250124 = (0, import_provider_utils15.createProviderDefinedToolFactory)({
  id: "anthropic.computer_20250124",
  name: "computer",
  inputSchema: computer_20250124InputSchema
});

// src/tool/memory_20250818.ts
var import_provider_utils16 = require("@ai-sdk/provider-utils");
var import_v413 = require("zod/v4");
var memory_20250818InputSchema = (0, import_provider_utils16.lazySchema)(
  () => (0, import_provider_utils16.zodSchema)(
    import_v413.z.discriminatedUnion("command", [
      import_v413.z.object({
        command: import_v413.z.literal("view"),
        path: import_v413.z.string(),
        view_range: import_v413.z.tuple([import_v413.z.number(), import_v413.z.number()]).optional()
      }),
      import_v413.z.object({
        command: import_v413.z.literal("create"),
        path: import_v413.z.string(),
        file_text: import_v413.z.string()
      }),
      import_v413.z.object({
        command: import_v413.z.literal("str_replace"),
        path: import_v413.z.string(),
        old_str: import_v413.z.string(),
        new_str: import_v413.z.string()
      }),
      import_v413.z.object({
        command: import_v413.z.literal("insert"),
        path: import_v413.z.string(),
        insert_line: import_v413.z.number(),
        insert_text: import_v413.z.string()
      }),
      import_v413.z.object({
        command: import_v413.z.literal("delete"),
        path: import_v413.z.string()
      }),
      import_v413.z.object({
        command: import_v413.z.literal("rename"),
        old_path: import_v413.z.string(),
        new_path: import_v413.z.string()
      })
    ])
  )
);
var memory_20250818 = (0, import_provider_utils16.createProviderDefinedToolFactory)({
  id: "anthropic.memory_20250818",
  name: "memory",
  inputSchema: memory_20250818InputSchema
});

// src/tool/text-editor_20241022.ts
var import_provider_utils17 = require("@ai-sdk/provider-utils");
var import_v414 = require("zod/v4");
var textEditor_20241022InputSchema = (0, import_provider_utils17.lazySchema)(
  () => (0, import_provider_utils17.zodSchema)(
    import_v414.z.object({
      command: import_v414.z.enum(["view", "create", "str_replace", "insert", "undo_edit"]),
      path: import_v414.z.string(),
      file_text: import_v414.z.string().optional(),
      insert_line: import_v414.z.number().int().optional(),
      new_str: import_v414.z.string().optional(),
      old_str: import_v414.z.string().optional(),
      view_range: import_v414.z.array(import_v414.z.number().int()).optional()
    })
  )
);
var textEditor_20241022 = (0, import_provider_utils17.createProviderDefinedToolFactory)({
  id: "anthropic.text_editor_20241022",
  name: "str_replace_editor",
  inputSchema: textEditor_20241022InputSchema
});

// src/tool/text-editor_20250124.ts
var import_provider_utils18 = require("@ai-sdk/provider-utils");
var import_v415 = require("zod/v4");
var textEditor_20250124InputSchema = (0, import_provider_utils18.lazySchema)(
  () => (0, import_provider_utils18.zodSchema)(
    import_v415.z.object({
      command: import_v415.z.enum(["view", "create", "str_replace", "insert", "undo_edit"]),
      path: import_v415.z.string(),
      file_text: import_v415.z.string().optional(),
      insert_line: import_v415.z.number().int().optional(),
      new_str: import_v415.z.string().optional(),
      old_str: import_v415.z.string().optional(),
      view_range: import_v415.z.array(import_v415.z.number().int()).optional()
    })
  )
);
var textEditor_20250124 = (0, import_provider_utils18.createProviderDefinedToolFactory)({
  id: "anthropic.text_editor_20250124",
  name: "str_replace_editor",
  inputSchema: textEditor_20250124InputSchema
});

// src/tool/text-editor_20250429.ts
var import_provider_utils19 = require("@ai-sdk/provider-utils");
var import_v416 = require("zod/v4");
var textEditor_20250429InputSchema = (0, import_provider_utils19.lazySchema)(
  () => (0, import_provider_utils19.zodSchema)(
    import_v416.z.object({
      command: import_v416.z.enum(["view", "create", "str_replace", "insert"]),
      path: import_v416.z.string(),
      file_text: import_v416.z.string().optional(),
      insert_line: import_v416.z.number().int().optional(),
      new_str: import_v416.z.string().optional(),
      old_str: import_v416.z.string().optional(),
      view_range: import_v416.z.array(import_v416.z.number().int()).optional()
    })
  )
);
var textEditor_20250429 = (0, import_provider_utils19.createProviderDefinedToolFactory)({
  id: "anthropic.text_editor_20250429",
  name: "str_replace_based_edit_tool",
  inputSchema: textEditor_20250429InputSchema
});

// src/anthropic-tools.ts
var anthropicTools = {
  /**
   * The bash tool enables Claude to execute shell commands in a persistent bash session,
   * allowing system operations, script execution, and command-line automation.
   *
   * Image results are supported.
   *
   * Tool name must be `bash`.
   */
  bash_20241022,
  /**
   * The bash tool enables Claude to execute shell commands in a persistent bash session,
   * allowing system operations, script execution, and command-line automation.
   *
   * Image results are supported.
   *
   * Tool name must be `bash`.
   */
  bash_20250124,
  /**
   * Claude can analyze data, create visualizations, perform complex calculations,
   * run system commands, create and edit files, and process uploaded files directly within
   * the API conversation.
   *
   * The code execution tool allows Claude to run Bash commands and manipulate files,
   * including writing code, in a secure, sandboxed environment.
   *
   * Tool name must be `code_execution`.
   */
  codeExecution_20250522,
  /**
   * Claude can analyze data, create visualizations, perform complex calculations,
   * run system commands, create and edit files, and process uploaded files directly within
   * the API conversation.
   *
   * The code execution tool allows Claude to run both Python and Bash commands and manipulate files,
   * including writing code, in a secure, sandboxed environment.
   *
   * This is the latest version with enhanced Bash support and file operations.
   *
   * Tool name must be `code_execution`.
   */
  codeExecution_20250825,
  /**
   * Claude can interact with computer environments through the computer use tool, which
   * provides screenshot capabilities and mouse/keyboard control for autonomous desktop interaction.
   *
   * Image results are supported.
   *
   * Tool name must be `computer`.
   *
   * @param displayWidthPx - The width of the display being controlled by the model in pixels.
   * @param displayHeightPx - The height of the display being controlled by the model in pixels.
   * @param displayNumber - The display number to control (only relevant for X11 environments). If specified, the tool will be provided a display number in the tool definition.
   */
  computer_20241022,
  /**
   * Claude can interact with computer environments through the computer use tool, which
   * provides screenshot capabilities and mouse/keyboard control for autonomous desktop interaction.
   *
   * Image results are supported.
   *
   * Tool name must be `computer`.
   *
   * @param displayWidthPx - The width of the display being controlled by the model in pixels.
   * @param displayHeightPx - The height of the display being controlled by the model in pixels.
   * @param displayNumber - The display number to control (only relevant for X11 environments). If specified, the tool will be provided a display number in the tool definition.
   */
  computer_20250124,
  /**
   * The memory tool enables Claude to store and retrieve information across conversations through a memory file directory.
   * Claude can create, read, update, and delete files that persist between sessions,
   * allowing it to build knowledge over time without keeping everything in the context window.
   * The memory tool operates client-side—you control where and how the data is stored through your own infrastructure.
   *
   * Supported models: Claude Sonnet 4.5, Claude Sonnet 4, Claude Opus 4.1, Claude Opus 4.
   *
   * Tool name must be `memory`.
   */
  memory_20250818,
  /**
   * Claude can use an Anthropic-defined text editor tool to view and modify text files,
   * helping you debug, fix, and improve your code or other text documents. This allows Claude
   * to directly interact with your files, providing hands-on assistance rather than just suggesting changes.
   *
   * Supported models: Claude Sonnet 3.5
   *
   * Tool name must be `str_replace_editor`.
   */
  textEditor_20241022,
  /**
   * Claude can use an Anthropic-defined text editor tool to view and modify text files,
   * helping you debug, fix, and improve your code or other text documents. This allows Claude
   * to directly interact with your files, providing hands-on assistance rather than just suggesting changes.
   *
   * Supported models: Claude Sonnet 3.7
   *
   * Tool name must be `str_replace_editor`.
   */
  textEditor_20250124,
  /**
   * Claude can use an Anthropic-defined text editor tool to view and modify text files,
   * helping you debug, fix, and improve your code or other text documents. This allows Claude
   * to directly interact with your files, providing hands-on assistance rather than just suggesting changes.
   *
   * Note: This version does not support the "undo_edit" command.
   *
   * Tool name must be `str_replace_based_edit_tool`.
   *
   * @deprecated Use textEditor_20250728 instead
   */
  textEditor_20250429,
  /**
   * Claude can use an Anthropic-defined text editor tool to view and modify text files,
   * helping you debug, fix, and improve your code or other text documents. This allows Claude
   * to directly interact with your files, providing hands-on assistance rather than just suggesting changes.
   *
   * Note: This version does not support the "undo_edit" command and adds optional max_characters parameter.
   *
   * Supported models: Claude Sonnet 4, Opus 4, and Opus 4.1
   *
   * Tool name must be `str_replace_based_edit_tool`.
   *
   * @param maxCharacters - Optional maximum number of characters to view in the file
   */
  textEditor_20250728,
  /**
   * Creates a web fetch tool that gives Claude direct access to real-time web content.
   *
   * Tool name must be `web_fetch`.
   *
   * @param maxUses - The max_uses parameter limits the number of web fetches performed
   * @param allowedDomains - Only fetch from these domains
   * @param blockedDomains - Never fetch from these domains
   * @param citations - Unlike web search where citations are always enabled, citations are optional for web fetch. Set "citations": {"enabled": true} to enable Claude to cite specific passages from fetched documents.
   * @param maxContentTokens - The max_content_tokens parameter limits the amount of content that will be included in the context.
   */
  webFetch_20250910,
  /**
   * Creates a web search tool that gives Claude direct access to real-time web content.
   *
   * Tool name must be `web_search`.
   *
   * @param maxUses - Maximum number of web searches Claude can perform during the conversation.
   * @param allowedDomains - Optional list of domains that Claude is allowed to search.
   * @param blockedDomains - Optional list of domains that Claude should avoid when searching.
   * @param userLocation - Optional user location information to provide geographically relevant search results.
   */
  webSearch_20250305
};

// src/anthropic-provider.ts
function createAnthropic(options = {}) {
  var _a;
  const baseURL = (_a = (0, import_provider_utils20.withoutTrailingSlash)(options.baseURL)) != null ? _a : "https://api.anthropic.com/v1";
  const getHeaders = () => (0, import_provider_utils20.withUserAgentSuffix)(
    {
      "anthropic-version": "2023-06-01",
      "x-api-key": (0, import_provider_utils20.loadApiKey)({
        apiKey: options.apiKey,
        environmentVariableName: "ANTHROPIC_API_KEY",
        description: "Anthropic"
      }),
      ...options.headers
    },
    `ai-sdk/anthropic/${VERSION}`
  );
  const createChatModel = (modelId) => {
    var _a2;
    return new AnthropicMessagesLanguageModel(modelId, {
      provider: "anthropic.messages",
      baseURL,
      headers: getHeaders,
      fetch: options.fetch,
      generateId: (_a2 = options.generateId) != null ? _a2 : import_provider_utils20.generateId,
      supportedUrls: () => ({
        "image/*": [/^https?:\/\/.*$/]
      })
    });
  };
  const provider = function(modelId) {
    if (new.target) {
      throw new Error(
        "The Anthropic model function cannot be called with the new keyword."
      );
    }
    return createChatModel(modelId);
  };
  provider.languageModel = createChatModel;
  provider.chat = createChatModel;
  provider.messages = createChatModel;
  provider.textEmbeddingModel = (modelId) => {
    throw new import_provider4.NoSuchModelError({ modelId, modelType: "textEmbeddingModel" });
  };
  provider.imageModel = (modelId) => {
    throw new import_provider4.NoSuchModelError({ modelId, modelType: "imageModel" });
  };
  provider.tools = anthropicTools;
  return provider;
}
var anthropic = createAnthropic();
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  VERSION,
  anthropic,
  createAnthropic
});
//# sourceMappingURL=index.js.map